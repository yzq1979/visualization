第一章   C++编程上手初体验

                                 ------ 万丈高楼平地起


   从起源上讲，C++是在C语言的基础上发展而来的，当时的目的是为了提供一个更好的C，为C语言增加面向对象的功能，并且为了能够被已经广泛使用C语言的程序员接受，C++尽可能保持和C语言的兼容。虽然经过几十年的发展，C++语言和C按照不同的轨迹前进，但是，C++的过程编程部分和C语言绝大部分相同，除了一些细微之处。C++开发环境中一般也支持开发C语言。
   
1.1 从hello world 开始
     按照传统惯例，我们从hello world程序开始认识C++程序。这个传统透露出第一个写这个程序的人的乐观态度，快乐编程！代码就是程序员的语言，用语言来表达自己的想法和思想。
　　闲话少说，切入正题：
　　
　　#include <iostream>
　　using namespace std;
　　
　　void main()
　　{
　　    cout<<"Hello world!"<<endl;
　　}
　　
　　整个程序很简单，只有短短几行代码，但是已经是个可以执行的完整C++程序。下面逐一说明对代码中的一些细节。
　　
预编译指令
　　#include是预编译指令中的一种，以#开头，是在编译源代码之前完成。#include <iostream>用来加载输入输出流，这样就可以使用内置定义的cin 和cout，，除了这种形式，还有#include < iostream.h> 这种较老的形式，这种形式，<> 与“”的区别：搜索头文件路径的不同，引号表示当前工作目录，尖括号表示软件的安装目录。
　　
预备语句
　　这只是一个不正规的说法，是指放在主函数前的语句，如using namespace std;
　　如果使用了#include <iostream>，则必须搭配using namespace std这一句，否则的话编译的时候，程序就会报告找不到cin 和cout，即cin cout这些都不可见。 这个说明要使用std这个命名空间，因为cin, cout这些对象都是定义于其中  命名空间对变量的使用范围进行了限制，防止变量名、函数名、类名的冲突。
　　类似于说 5班的张三 和6班的张三
　　
　　此外，也可以将全局变量、全局函数等定义放在这里。
主函数
　　一个工程中只包含一个main函数，即使有多个文件。每次程序执行的时候，都是首先找到main（）主函数，从第一行顺序执行到最后一行，然后结束。
　　注意主函数有多种不同形式，可能带有参数来支持命令行启动。
　　
注释
两种注释方法  /*   */     //
注释的位置：
文件头， 
包含：源文件的名字、作用、创建时间、作者、联系方式、文件的修改历史等信息，宣布版权信息或者帮助阅读者理解代码。

//Lab.cpp
//version:2.1
//Date:September 2001
//Author: 
//Email:
//Copyright © 2012. All Rights Reserverd.
//History:

注释的中文版或者英文版的选择
注释内容的选择：是否需要自动提取注释形成软件文档，是否团队已有规定的格式 。。


语句周围

注释不影响程序的任何功能，因为都是删除注释后再交给编译器进行编译的。但好的注释可以增强代码的可读性。

写注释的时候，可以先集中精神写完一段代码，再补上注释，特别是如果写中文注释的需要反复切换输入法，且容易打断编程的思路。

输入输出
　　很多时候程序需要与外界进行交互，获取输入数据和输出数据。但是这种界面并不完全指我们通常见到的GUI图形用户界面，还包括命令行窗口。我们在进入电脑的杀毒模式时会遇到。
　　C++的基本输入输出是采用标准类库（standard library）中的iostream类库来实现的。
在定义这个库的时候，C++引入了stream （流）的概念，来描述和建模数据的流向，这也是一种目前广泛应用的，如常见的打印作业流、网络视频流、音频流等，这种方式的好处是灵活方便，很容易在流的中间增加各种处理并且是实时不间断的，并且很形象，使人很容易联想到流水般的柔性和源源不断的特性。
　　流又可细分为输入流（istream）和 输出流（ostream），其中istream中的i代表 input （输入），ostream中的o代表output（输出）。在使用时只需要加载对应的头文件即可，即在代码中加上一句：#include <iostream>  using namespace std 。然后就可以使用cin和 cout这两个预先定义好的分别代表输入对象和输出对象。
　　cin的用法是 cin>>a, a是定义好的变量，即保持输入值的位置。
　　例如：
　　Cout<<2;   //输出2
　　Cout<<“Hello World！”  //输出字符串
　　Cout的用法是。。。。
　　>>和<<都是箭头形，代表了信息流的方向。由于键盘输入的值会直接存放在输入对象cin中，我们可以把cin直观地理解为输入设备，如键盘，cout为输出设备，如显示器。
　　注意，虽然#include <iostream.h>也管用，但是不提倡使用，要向最新标准靠拢。只有在需要考虑和旧代码兼容等问题的时候需要采用。
　　默认情况下，cout是输出到命令行窗口的。即每次运行程序时，自动出现的那个黑色的窗口。
　　由于CPU以及内存处理数据和传输数据的速度很快，而从内存到显示器等外设的速度则慢得多，因此，C++引入了输出缓冲区的概念。即程序产生的数据先保存在缓冲区内，CPU就不用管了，缓冲区负责一点点显示完成显示。
　　
　　为了更方便地对输入输出流进行控制，C++中还定义了一些“操纵符”，如endl操纵符的作用是对输出换行，并且刷新输出缓冲区，确保用户立即看到已经插入输出流的信息。
　　除此之外，如果需要更多的格式方面的要求，如小数的精度、输出字符的宽度、需要对输出流的格式进行控制。只需要加载头文件<iomanip>,就可以使用预定义好的常用操纵符了。其中，iomanip中的i和o分别代表input和output,manip则是英文单词manipulate（操作、操纵）的缩写。
　　常用的操纵符及功能列表如下：
　　
操纵符作用dec采用十进制表示数值数据hex采用十六进制表示数值数据oct采用八进制表示数值数据endl插入换行符，并刷新输出流Setprecion(int)设置浮点数的精度，包含小数点前后十进制数字的个数Setw(int)设置输出的两个数据显示的间隔宽度Setioflags()默认为文本右对齐，可以用这个修改　　
　　cin.get() char ch  cin>>char   system(“pause”);（要加入头文件stdlib.h）  使界面等待任意按键来关闭 ，或直接在cmd 窗口运行 D:\lab\...
　　
　　
Cin>>a,b 出错，正确的形式是cin>>a>>b;

一串 int 在输入的时候判断结束  
判断cin结束的标志

都会在后面的章节中详细描述


Cin  cout 输入输出缓冲（在dos ,linux等环境下的，或者开发windows程序的算法验证）
缓冲的刷新 endl

读取行  ，读取表示程序结束的 *  或者回车符 等

※ 读取文件
文件读写

Ctrl z 结束命令行的输入不管用
Getchar 与cin 暂停


◆ ofstream 文件读写
◆ cout的输出缓冲问题
◆cin函数的结束方法
cin同时读写两个


利用cin 输入数据的时候要用 空格 来分隔，不要使用逗号，  cin >> 与cout <<与 ；
连着输入两个字符，使用cin>>a>>b,也不要用逗号分隔；
◆空语句  

　　
　　
     当然，这只是个简单的例子，只是简单的说明了C++程序的一些基本概况，随着我们陆续学习更多的C++特性，我们就可以逐渐一睹C++的庐山真面目。
   
   我们已经了解了C++程序编写的过程，也了解了开发环境IDE，还有看到了一个经典而简单的hello world例子。下面我们就可以亲自动手，试着写几个C++的程序来练习下，找找感觉。
　　
　　
1.2 计算机的逻辑结构
　　


　　
第二章   多样化的类型和运算符
　　—— 神形兼备
　　
　　在这个世界中国，各种类型的数据，好比各种各样的生物，而数据类型所支持的各种运算符，是生物之间的相互关系，如依赖、共存、捕食、竞争等。数据类型和运算符组合起来，就构成了多样的表达式，则相当于自然界的秩序。
　　
　　编程语言的数据类型是对实际世界中的事物身份的抽象。类型是数据的身份，不同的身份，限定了可以做的事情和不可以做的事情，如支持的运算符等。但数据类型的鸿沟并不是绝对不可以逾越的，在必要的时候，编译器会按照默认的规则自动进行类型转换，此外，程序员也可以根据需要，强制进行类型转换， 
　　
　　数据类型相当于数据的属性，通过声明和使用这些数据类型的变量来描述现实世界中各种常用的数据。
2.1 各归其位，各司其职（类型）
　　C++是强类型的语言，这就意味着在C++中，每个都必须有身份，各归其位，各司其职。C++中的数据类型包括基本的数据类型（内置数据类型）和用户自定义数据类型。基本数据类型包括整型、浮点型、字符型、布尔型、字符串类型等。自定义数据类型需要用到类来定义，并且用运算符重载来模拟和内置类型一样的运算操作。
　　在C++ 98标准中，增加了 类型，
　　在最新的C++ 11标准中，专门增加了nullptr类型来取代以前的所谓的空指针类型null,null只不过是个定义好的宏语句， #define null 0 ，其实质与0无异，并不能很好地从根本区分空指针与空数值。
2.1.1 选择合适大小的数据类型
　　对于内置的数据类型，比如说int整数类型有int ，long int ，—int64类型,double浮点数类型有float,double等。需要根据需要选用合适的，不过，在很多情况下，现代编译器有能力进行自动优化，并且，目前大多数的情况下，内置数据类型的大小不再是系统性能的瓶颈。因此，一般整数类型用int，浮点类型用double就可以了，编译器很多时候会帮我们调整到合适的类型。
2.1.2 字符和字符串类型
  
ASCII值控制字符ASCII值控制字符ASCII值控制字符ASCII值控制字符 0 NUT 32 (space) 64 @ 96 、1 SOH 33 ！65 A 97 a 2 STX 34 ”66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 E 101 e 6 ACK 38 & 70 F 102 f 7 BEL 39 , 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 X 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 < 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 > 94 ^ 126 ~ 31 US 63 ? 95 —127 DEL 
　　　　　　　图  ASCII码表
　　观察上面这个表格，我们可以看到换行符、回车符这些文本编辑用的格式控制符都对应了字符。并且空格键与空字符并不相同。空格符是  ，空字符是    。
　　此外，对于转义字符，则采取在前面再加一个\来表示。
　　对于单字符，用单引号。对于多个字符，则用双引号。
　　
　　
2.1.3 数据类型的范围
采用模板的方式定义了变量的范围。
在库文件climits（limits.h）这个头文件中定义了各类数据类型的范围，使用方法如下：
它们以宏定义的方式进行定义climits中的符号常量  
符号常量表示CHAR_BITchar 的位数CHAR_MAXchar 的最大值CHAR_MINchar 的最小值SCHAR_MAXsigned char 的最大值SCHAR_MINsigned char 的最小值UCHAR_MAXunsigned char 的最大值SHRT_MAXshort 的最大值SHRT_MINshort 的最小值USHRT_MAXunsigned short 的最大值INT_MAXint 的最大值INT_MINint 的最小值UNIT_MAXunsigned int 的最大值LONG_MAXlong 的最大值LONG_MINlong 的最小值LONG_MAXunsigned long 的最大值
2.1.4 类型转换（角色的转换）
   C++做出这种选择，其实也是与其定位相关。C++定位于用来构建大规模的可靠程序，因此，严谨规范可控是其风格。这好比在大企业中，做事情都要求按照流程走，虽然有时候显得繁琐，但是如果工作人员的职责允许随意变动的话，由于企业规模增大，没法采用这种小作坊式的管理方式。因此，这就决定了C++不能采用过于动态的类型。
   但这并不是C++中的类型是从生到死都是固定不动的，不变是相对的，变化是绝对的，C++中的不同类型也能相互转换。即使大企业中，也会有人员的调整和调动，关键是要规范可控，要按照规定的流程走。在C++中，类型转换分为自动类型转换和强制类型转换，分述如下：
2.2.4.1 自动类型转换  
Double到Int类型的自动转换，注意是直接舍弃小数点后面的，没有四舍五入。

还有一类特殊的类型转换，char到int的自动转换。

由于ASCII码的存在，每个字符类型根据ASCII码表，可以对应一个int类型的数据。C++编译器也默认根据这个来解释char类型和int类型的加减等运算。
比如，对于下面的例子，就完成了大写字符到小写字符的转换功能
 #include "iostream"
 using namespace std;
 void main()
 {
   char a,b,c;
   cout<<"input character a,b,c";
   cin>>a>>b>>c;
   cout<<a<<b<<c;
   a=a-32;b=b-32;c=c-32;
   cout<<a<<b<<c<<endl;
}
　　这段代码之所以有效，是因为在码表中，刚好大写字母和小写字母的编码位置间隔是32。


2.2.4.2 强制类型转换
　　需要强调的是，强制类型转换并不是C++所提倡的，只能在必要的时候进行。因为，类型转换容易违反阅读代码时形成的认识，不利于理解代码，且会带来效率的损失。
　　C++中的强制类型转换有两种，一种是从C语言而来，在表达式中直接用小括号写明目的的数据类型，放置在待转换的变量前面。如 (int)a ，表示将变量a转换为int类型。
　　据说，C++中的强制类型转换采用这种长而丑陋的命名也是让程序员在使用的过程中三思而行，是否真的有必要。

2.2 诚于中而形于外（运算符）
C++中有极其丰富的运算符，除了我们通常理解的加、减、乘、除外，还有 这些运算符和数据类型搭配起来，就构成了表达式。他们代表的是多种多样的相互关系

对数据处理就是对数据进行各种运算，以获得某个运算结果。

在表达式中，每个运算符需要的操作数不同，最常见的是需要两个操作数，称为二元运算符，如常见的加、减、乘、除运算符，另外还有只需要1个操作数的为一元操作符，如自增 ++  ,需要3个运算符的，如。。
2.2.1 算术运算符
算术运算符是最传统也是最常用的，主要有：
+（加）：计算两个数的和。
-（减）：计算两个数的和。
*（乘）：计算两个数的和。
/（除）：计算两个数的和。
%（取余）：计算两个数的和。

　　这里面，需要注意的是 / （运算符），C++中特别规定，如果分子和分母都为整数的话，那么计算出的结果就是整除值（是直接截断，而非四舍五入），这样才能 满足a/b +a%b=a 这一限制条件。
    如  5/2 的结果是2，而非2.5
















2.2.2 关系运算符
C++中的关系运算符包括下面几种：   >   （大于）   >= （大于或等于）  < （小于）  <=（小于或等于）  == （等于） != （不等于）

需要注意的是：
双字符的关系运算符（ &&    ||）中加上 空格 ，是否能通过编译
        不要将== 误写作  =

关系运算符是二元操作符，其运算结果是bool类型，如果符合则为true，反之为false，常用来判断某种条件是否成立。

   针对关系运算符常用于条件判断的情况，C++专门提供了条件运算符用于简化这类语句。
　　条件运算符是C++提供的唯一1个三元操作符，其语法为：
　　条件判断表达式?表达式1 :表达式2
　　
　　如果判断结果为true，则执行表达式1 
　　如果为false，则执行表达式2
　　
　　例子：
　　int x=5;
　　int y=6;
　　
　　int min=x<y ? x: y;
2.2.3 逻辑运算符
   对于更复杂的表达式，需要根据多个关系运算的结果再进行运算，也就是说，处理 true 和 false类型数据的运算符。C++中的逻辑运算符就是用于这种用途。
&&  逻辑与 || 逻辑或   ！逻辑非

注意：C++中特有的“短路运算”，来源于电子电路中的并联电路，如果某个分支短路了，则所有的电流都会从短路的分支通过，整个电阻几乎为0，与其它并联的电阻完全无关。
短路运算是，对于逻辑与运算，只要1个为false，整体结果就是false，无需继续计算，对于逻辑或，只要1个为true，整体结果就是true，也无需继续计算

2.2.4 赋值运算符
　　赋值也是最常见的操作符，顾名思义，其作用是将变量赋予新的值。需要注意的是，可能会存在类型自动转换的情况。
　　
　　赋值运算符可以和前面提到的算术运算符相结合，构成复合运算符，如  +=  -=  /= %=  
　　此外，位运算符也可以和赋值运算符复合，如  <<=  >>=  &=  ^=   |=  
2.2.5 其它特有的运算符
2.2.6 位运算符
　　C++一直保留了从C语言中继承而来的位运算符，这使得C++同样能够很方便地用于底层的操作，适用于嵌入式或者操作系统等底层的开发。
　　这些位运算符有：
　　
　　
2.2.7 自增、自减运算符
　  ++或者—可以说是C++的标志性外观特征之一，甚至C++本身的命名也深受影响。++英文读作plus plus ，但是大家约定熟成读作 加加，倒也通熟易懂并且简洁。
　
　
   引入这种符号，C++考虑最多的是一种高运行效率的表示，其次是考虑了简洁。

x=x+1,x+1,x++,哪个效率最高?为什么?2010-01-09 10:03x=x+1最低，因为它的执行过程如下：

（1）读取右x的地址

（2）x+1

（3）读取左x的地址

（4）将右值传给左边的x(编译器并不认为左右的x的地址相同)

x+=1其次，其执行过程如下：

（1）读取右x的地址

（2）x+1

（3）将得到的值传给x(因为x的地址已经读出)

x++效率最高，其执行过程如下

（1）读取右x的地址

（2）x自增1

++或者--可以放在前面，也可以放在后面，分别称之为前置运算符和后置运算符。
其区别主要在与，前置的是 先完成自增或者自减，然后参与表达式的运算，后置的是先参加完表达式的运算，然后再进行自增或者自减。

如  int a=1;
int b=2;
int c=5
c=a+ b++;  //计算结果c为3，b为3
c=a+ ++b;  //计算结果c为4，b为4


VC编辑器的watch 状态栏显示的是 计算出的表达式，、
如 
	int a;
	cin>>a;
	cout<<a++<<endl;

在调试状态下，细心的同学观察到一些好像不正常的现象。比如说，输入8,则输出9，但是F10单步运行，则watch中的a++的值为10.

原因在于： watch状态栏在显示结果的时候，首先计算了 a++的值。
2.2.8 逗号运算符
不是很提倡使用
2.2.9 Sizeof()运算符

2.2.10 运算符的优先级和结合性
   虽然很多书中都列出了运算符的优先级表，但是完全记住很困难也没有必要。
只要记住几点：
   小括号 ()  的优先级最高；
　　同一优先级的运算符，从左到右进行运算。
　　其它具体的优先级，用多了自然就记住了，在编写程序的时候如果不确定，在书本或者网上查阅资料即可。
　　
   虽然，复杂的表达式比单独拆分后的各表达式是效率高一些的，但是过于复杂的表达式
不仅很难阅读，在编写的时候也很容易出错。所以应该适当进行拆分，在效率和人性化中求平衡。 

多用小括号来区分运算符的优先级  
    除非是 1+2*5  这类很常用的表达式，这样可以提高程序的可读性，且不易出错
    






第三章  从语句到结构
　　——独木不成林

　　在了解了各种基本的数据类型及其所支持的运算符后，还并不能组织成有效的代码，正所谓“独木不成林”。还必须先组成各种功能用途的语句，再组成功能各异的几种结构。下面逐一描述。
3.1 精确的语句与严格执行的命令
　　语句是代码运行的最小单位，每条语句在C++中用分号隔开，代表了一个独立的控制语句，对应了一个独立的控制指令，即要求计算机完成什么任务。
　　计算机是精确的，因此，我们写给计算机看的语句也应该是严谨而精确，否则，计算机就理解不了或者理解有歧义。
　　根据用途，可以将C++中的语句划分为定义语句、控制语句等多种。
　　根据前面定义的数据类型，我们可以构建出表达式语句，除此之外，还有定义语句、控制语句等。
　　
3.1.1 并不多余的声明

const和#define的比较
const有数据类型，#define没有数据类型
个别编译器中const可以进行调试，#define不可以进行调试

C++中较严格地区分了声明和定义。




3.1.2 空语句的唯一用途
空语句是一类特殊的语句，什么操作也不完成。其唯一的用途是在和循环一起中，执行延时。

如  for(int i=0;i<1000000;i++)
;
正因为空语句在C++是合法的，因此，要谨防一类很常见的错误，循环头和条件头后面加上分号。 就成为了死循环！


3.1.3 赋值语句与迭代计算
赋值语句虽很常见，但是体现了现代顺序程序设计的根本和精髓，通过迭代更新来得到最终的值，与此对应的是函数式编程，通过表达式的运算。




3.1.4 极度灵活的跳转语句
　　这些转向语句，对应到汇编，调用的是各种形式
　　的jump语句。
Break 可能影响循环的次数，continue 不会
     
     几个特殊的转向语句：（改变原来程序执行的顺序）
     
3.1.5 return往何处？



3.1.6 Goto语句的功与过
避免使用goto语句 
       早期的程序设计时用 goto来实现程序控制流程的跳转。但是随着程序设计实践的发展，人们发现了goto语句的很多弊端，使程序难以维护，破坏结构化程序设计的风格，带来错误和隐患。
       现代程序开发规模越来越大，开发和维护很多时候是由不同人员进行的，因此很多情况下强调清晰的编程风格，只有在很必要（能显著改进算法效率等情况下 ）才使用编程技巧。
　　　　在循环语句中用continue 和break语句来控制流程，其中continue 是跳出本次循环，继续下一次循环， break是直接跳出循环

Goto语句的的优点是很直接，缺点是太直接！

可读性较低
事實上，C/C++語言有提供一種不在以上三種結構範圍內的結構，叫做
1. goto label;  
goto label;
它可以跳到整個程式的任意一個點，自從前面三種元素被證明可以寫出任何程式之後，goto就漸漸地與邪惡、惡魔劃上等號，也就是，使用了goto會下地獄! 不是真正的地獄，而是程式設計與維護上的地獄，曾經有人形容用goto寫出來的程式像是一盤義大利麵，程式碼片段間不停的跳躍，每一行程式碼都有可能是進入點和出口，在這樣錯縱複雜的goto使用之下，程式碼變得難以理解和維護，而後來有偉大的人，證明了goto能寫出來的程式，使用以上三種結構都一樣可以寫出來，自此之後人們就和邪惡的goto漸行漸遠，但是C語言在那個時代下還沾染了這樣邪惡的特性，雖然你一樣可以使用它，但是請當做沒有這樣的邪惡語法存在，記住，否則你會下地獄

     相較之下，結構化程式設計只有單一個進入點，單一個出口，就像一個房間一樣，你得從入口進入，從出口離開，哪裡發生命案(錯誤、bug之類的)，只要把進出的可能性都考慮過，就很容易可以找到兇手到底是誰，但是惡魔的做法並不是如此，goto就像是可以穿牆的人，他自由進出每個房間，你難以得知到底有哪個goto來過這裡，還有他何去何從，在這樣的程式裡發現了錯誤或bug，你難以得知兇手到底是誰，因為整個世界的人都有嫌疑，他們都可能穿牆進入房間謀殺了某個人然後揚長而去，這就是goto邪惡的原因


受限的Goto： break语句与continue：
       （1）使用范围：只能用在switch语句和循环语句中
       （2）从break语句处跳出switch语句或循环语句，转去执行switch语句或循环语句之后的语句。Switch语句前面
                  讲过,在循环语句中：
               ①    用来提前终止循环。
                Eg. for(i=10;i<20;i++){
                              if(i%3==0) break;
                              cout<<i<<" ";
                       }
                   该程序执行后的结果为： 10  11
               ②  在for(;;)的语句形式中，避免死循环：
                         一般用法：for(;;){
                                                    …
                                           if(表达式) break;
                                                   …
                                            }
                         注意：在嵌套循环中，break语句终止的是其所在的循环语句，而并非所有的循环。
                 Eg. for(;;){
                           for(;;){
                                    …
                                    …  break;
                                    …
                          }
                            语句1；
                              …
                    ｝
                    当程序执行到break语句时，终止的是内层循环，接着执行语句1。
     
   continue
　　         (1) 使用范围：只能用在循环语句中。
            （2）作用：用来终止本次循环。即：当程序执行到continue语句时，将跳过其后尚未执行的循环体语句，开始
                                下一次循环。Eg. 
                                      for(i=10;i<20;i++){
                                               if（i%3==0） continue;
                                                cout<<i<<" ";
                                   }
                                该程序段的执行结果为：
                                     10  11  13  14  16  17  19 
         continue语句与break语句的区别：
     continue语句结束的是本次循环，而break语句结束的是整个循环





3.1.7 分工协作的函数调用
　　随着复合语句的规模增大，人们就将其独立分出来，作为一段子程序，只在原位置留下一个简单的函数调用语句，相当于出入口。程序从这个地方进入子程序，又从这个地方返回主程序。
　　
　　
　　
　　
　　
3.2 功能各异的结构
　　前面讲的语句与汇编几乎是一一对应的，但是这种方式，对于复杂的问题，不便于思考，因此，划分出几类结构，每类结构是由若干个语句组成，也即汇编层的若干操作指令和jump指令。
　　这有些像生物中的元素构成了细胞、细胞构成了功能结构、功能结构构成了生物。。。
　　
　　有了语句，就可以构成了完成的可运行的程序。这种程序都是我们通常所说的顺序结构程序，对于稍微复杂的程序，都需要根据情况进行程序的跳转，即进行程序流程的控制，在程序设计的早期是采用goto语句进行跳转的，这也是和硬件直接对应的。但是这种硬件思维用在软件则带来很多随意，容易被滥用，使得很多软件语句无法与硬件对应起来。
　　在硬件设计领域，在实践中，也逐步总结了很多的经验教训。对于硬件布线设计，也有很多规范化的限制，强调的是整齐清晰的结构，如减少不同板块之间的接口连线等，这些原则和约定。同样，软件设计中也有很多类似的约定，如单进单出原则。这些原则是为了将乱糟糟的一团乱麻式的代码结构梳理清晰，便于理解和维护，，也是在编程中追求美的一种过程。
　　虽然软件中的代码语句没有像硬件那样直观，但是乱糟糟的代码还是能感觉到。这样的代码不仅开发效率很低，而且几乎是不可维护的。对这些代码进行整理，最核心的就是对几乎无限制的跳转功能增加些约束。分别对应于最常用的两种情况，专门设计了这两种结构就是选择语句和循环语句，并且添加了一些语法约束和风格约束，从而从制度上和道德上限制了跳转功能，类似于硬件上通过相应的硬件限制结合起来。
　　
　　目前的计算机采用的是冯洛伊曼的结构，是通过对变量的不断迭代更新，存储当前的值。因此，选择结构则是根据某个值进行判断，循环则是不断更新某个值。
　　
　　结构化编程的原则的提出将众多的结构归纳为三种，顺序、选择、循环。已经从数学上证明证明，用顺序结构、选择结构、循环结构这几种，可以表示所有的程序结果。这三种的结构图分别如下：
　　也就是说，只要掌握了这3种结构，就可以写出任何程序。我们平时所见到的代码，都是这几种结构组合而来的。比如说，选择语句和循环语句里面的代码都是循环执行的、选择语句可以嵌套，循环也可以嵌套，选择语句中可以循环，循环中可以选择。
　　
　　
　　下面分别加以说明：
　　　　　　　　　　　　　
3.2.1 顺序结构的基础本质特征
      在目前传统的计算机中，结构决定了代码本质上都是顺序执行的。
　　　这可能和我们的直观感觉违背，很多时候，我们感觉同时在运行的，如一边听歌一边编写代码。其实，在硬件层次都是顺序执行的，哪怕是双核的，也是操作系统控制一部分的代码分开运行，轮流执行操作，只是因为计算机执行速度很快，所以我们感觉不到而已。

  顺序结构是最简单的，从上而下，一条直线运行，从main函数到结束。






    特点：算法步骤按照书写次序依次执行。
    如：求两个整数的和。
           int a,b,sum=0;
          cin>>a>>b;
          sum=a+b;
          cout<<sum;


　　　　　　　　　　　　　
3.2.2 选择结构（0和1的非此即彼）
　　选择结构主要功能是判断给定的条件，根据判断的结果从给定的多组操作中选择一组执行。
　　选择结构  if结构（单选择）   if/else（双重选择） switch(多重选择)
　　
　　
　　主要用CMP指令。
3.2.2.1 If else结构
　　　　If else是选择结构中比较简单的，是非此即彼的选择，只有向左或者向右的两个选择。
　　　　其语法如下：
　　if (条件表达式)
　　{
　　	语句1;
　　} 
　　else
　　{
　　	语句2;
　　}
　　
1. 优化选择结构的效率
（1） 用if else 嵌套结构来代替多句if语句，避免多次比较，提高程序效率

（2） 在 if/else 结构中，把为true 的概率较高的条件判断置于前面，这样可以提高该段程序的效率。
　　
 A的取值范围 {1,2,3,3,2，3,3,3，}    1个1,2个2 ，5个3 共8个数
任务：遍历输出所有的值
   if（a==1) 
			cout<<“a=1”;
   if（a==2) 
		     cout<<“a=2”;
   if（a==3) 
	   	cout<<“a=3”;


如果a等于3的情况最多，就放到前面，很多情况下可以减少比较的次数2次，如果多次循环，则能显著提高运行效率
   if（a==3) 
			cout<<“a=3”;
   else
{
   if（a==2) 
		cout<<“a=2”;
   if（a==1) 
		cout<<“a=1”;
}




2. 避免if else的常见错误
　　If else语句虽然简单，但是，在使用的过程中，也很容易犯不少的错误，特别是对于初学者。








（1） 避免括号引起的错误。

If之后的条件表达式应该加上括号

用大括号将多行语句组合成一个语句块 
　　if(a==1)
      b=5;
      i++;
    else
      b=7;
      i--;


		加大括号前后有何不同？


　嵌套If else 或者循环  结构中的大括号的配对，便于阅读，避免错误  多个屏幕 //end of if 
　

（1） 不要添加多余的分号
  除了括号外，随手添加一个分号，也是容易犯的错误之一。
if(a==b);
   c=a+b;  
等价于
if (a==b) 
       ;     //空语句,不执行任何操作
  c=a+b;





（2） 区别数学表示和计算机程序的表示方式。

区分==与=  
    将if(a==2)误写成if(a=2)会带来什么后果？
   错误防范：可以写为if(2==a)，若写错了，则编译器会发现错误
   牢记：尽可能把错误都在编译阶段暴露出来，在程序运行阶段找出错误的代价很大，会花费大量的时间和精力。   
   有时，编译器多找到几处错误并不是坏事


避免浮点变量和零值的比较
       计算机表示的浮点数（float或者double类型）都有精度限制，对于超出精度限制的浮点数，计算机会它们精度之外的小数部分截断，因此本来不相等的两个浮点数在计算机中就可能相等了。
　　　　因此，判断两个浮点数是否相等，判断条件为两个数之差的绝对值小于精度，比如说1E-6；判断某个浮点数等于0，判断条件为该数的绝对值小于精度。
　　　　
　　　　//错误的代码
　　　　#include<iostream>
　　　　using namespace std;
　　　　void main()
　　　　{
　　　　   double x=6.000000001;
　　　　   double y=6.000000002;
　　　　   if (x==y)
　　　　      cout<<"x和y相等！"<<endl;
　　　　}
　　　　
　　　　//正确的代码
　　　　#include<iostream>
　　　　using namespace std;
　　　　void main()
　　　　{
　　　　   double x=0.000000001;
　　　　   double y=0.000000002;
　　　　   if (abs(x-y)<1E-6)
　　　　      cout<<"x和y相等！"<<endl;
　　　　}





  取值范围的表示  if(17<age<35) 等价于 if ((17<age)<35)
因为< 操作符是从左到右结合，所以表达式的结果恒为true，即if语句的代码肯定会执行
正确的表示：  if(age>17  &&  age<35)
如表示数字和变量的乘积   如：1-2i 等，正确表示百分号 如：10%


（3） 不要将布尔变量与任何值进行比较，那会很容易出错的。
3.2.2.2 Switch case 结构
　　并列选择语句需要多次判断才能做出选择，对于并列选择项较多的情况（这种情况还很常见），这样既使代码显得繁琐，也会影响到代码执行的效率。因此，C++专门提供了专门的switch语句来代替复杂的并列选择语句。
　　
　　
　　
　　
　　
　　
　　
　　Switch case 语句的语法：
　　switch (条件表达式)
　　{
　　	case 常量表达式1:
　　		语句1;
　　		break;
　　
　　	case 常量表达式2:
　　		语句2;
　　	break;
　　
　　	case 常量表达式2:
　　		语句2;
　　	break;
　　}
　　

（1） Switch后面的值或者表达式必须是为常量且为整型（或可以转换为整型），这样才能在编译器进行计算，且常量表达式的值不能相同，即不能出现两个相同的case分支。)此外，注意单个字符变量加单引号。






（2） 不要忘记为case语句加上break (表示不同的含义，编译器不会提示错误！不要忘记了default语句
	char val;
	cin>>val;
	switch (val) 
	{	case 'a':
				cout<<"输入值为a"<<endl;
				break;
		case 'b' :
				cout<<"输入值为b"<<endl;
				break;	

不要忘记default语句，用于处理剩余的各种情况。类似于else 语句。




3.2.3 循环结构的效率
运行效率和代码编写效率，简洁优雅
3.2.3.1 几种循环结构的相互转换 




思考问题：如何对1到100累加求和

针对计算机的特点，将问题转换为累加的形式，从重复的现象，找出简单的逻辑，然后用循环表达式表示出来。


在循环语句中，我们习惯用诸如i，j，k之类的字母作为变量名，来控制循环的执行次数。这些变量又称为循环控制变量





嵌套的 循环好比时钟，秒钟 转了一圈，分钟才动一格

例子：时钟

典型用法  今后将学到的二维数组  二重循环
学会循环的思维方式和思维的表达，找出其中的规律


　　
这里的循环指从代码结构上体现的程序执行流程。


　　常见的循环有三种，分别是for循环，while循环，do while循环，这三种循环方式都有其优点，并且能相互转化。
算法时间：累加与循环控制变量
在循环结构中，累加是很常用的一种方法。累加分两种：常量累加和变量累加。常量累加就是类似i=i+1，即在自身的数值上每次递增1。这种方法一般用来记数，然后利用这个计数器作为条件帮助循环语句或分支语句做一些判断。变量累加一般是用于保存结果的，不管是1+2+3……+100还是1*2+2*3+3*4……+99*100都需要用到变量累加。变量累加一般和循环控制变量是有关系的，比如程序5.1.1中的累加值就是循环控制变量i，而1*2+2*3……中的累加值就是i*(i+1)了。


3.2.3.2 for循环 
  while循环的语法如下：

for (初始化语句;条件表达式;变化语句)
{
	循环体内语句;
}

while循环的流程图如下：

　　for循环是很直接的，直接指明了循环的次数（起始值与结束值）、循环的变换规律。因此，一般适用于循环的次数已知的情况。这种，将循环所有信息集中放置在一起，很便于快速查看，避免错误。
　　
　　
　　
　　如对于for (int i=2;i<5;i++)
　　{
　　	cout<<i<<endl;
　　} 
　　
　　此外，循环变量也可以只是用来表示循环的次数，而在循环体内不使用。
　　
　　如将上例改为：
　　for (int i=2;i<5;i++)
　　{
　　	cout<<” ”<<endl;
　　} 
　　则表示只是输出了4个空格。

特别地，对于这种情况，C++ 11标准中的新 for 循环语句。 For each

    For 循环虽然简单，但也有些地方需要注意：
1. 循环变量一般依次使用 i,j,k…，特别是对于循环中再来一次循环，也就是所谓的“嵌套循环”语句。
　　for (int i=2;i<5;i++)
　　{
　　	for (int j=3;j<6;j++)
　　	{
　　		cout<<i+j<<endl;
　　	}
　　}

2. For循环条件中 A=i++  与 a=++I; 的区别



3. 一般不要在for循环内部修改循环变量的值
没有语法错误，但是违反对于循环的普遍认识
for(int i=0;i<100;i++)  
{    i++
}

不会执行100次！
可改为：for(int i=0;i<100;i+=2)


4. 在for循环控制变量的计数时，防止“差1”错误！
for循环常和数组搭配,而数组的下标从0开始
如 for(int i=0;i<N;i++) 
  for(int i=0;i<=N-1;i++)
  for(int i=1;i<=N;i++) 
  for(int i=1;i<N+1;i++)
这些都是循环N次。


或者倒过来进行循环：
如 for(int i=N;i>0;i--) 
  for(int i=N;i>=1;i--)
  for(int i=N-1;i>=0;i--) 
  for(int i=N+1;i>1;i--)
这些也都是循环N次。
举一反三：在处理 while 循环 和 do while 循环的时候也要注意循环变量的值的变化

5. 不要随意省略for 语句中的条件，以免给理解程序带来麻烦
记住：程序不仅仅是写给现在的自己看的！。 注意黑体的部分

6. 避免因多余的分号而引起的空语句

3.2.3.3   while 循环 
while循环的语法如下：
while循环的流程图如下：


while循环适合于循环次数不定，用判断语句来看是否满足条件。
1. 不要加上多余的分号
     int i;
	cin>>i;
	while (i>0)  ;   //此处为死循环
	{
		cout<<"输入为正数";
	}	
	cout<<"输入结束！";

//去掉分号后依然为死循环，将cin语句放//到while循环条件中或使用do while 循环


2. 记得初始化变量，否则会导致错误的结果，
如果变量为指针变量的话，则可能导致不确定结果！
	int i;
	while (i>-2)  
		i++;

3.2.3.4  do while循环
while循环的语法如下：
　　流程如下：
　　
　　
　　从图可以看出，do while循环和while循环很类似，区别在于do while循环是先执行代码再判断是否继续循环，while循环则首先判断是否满足循环条件，若满足了再执行。两者是等价的，可以很容易转换。

3.2.3.5 迭代循环与递归循环 

3.2.3.6 从重复规律到循环执行

最重要的是，找到重复的规律，将问题转化为循环的形式，不管是迭代循环，还是递归循环，也就是把思路用适用于计算机的方式来思考问题。
发现可以用循环来高效解决的。

举例：
杨辉三角，五子棋等。



第四章   整齐划一的数组
　　									   ——沙场秋点兵
　　数组顾名思义，是数据的组合，但是只凭这个，我们还没办法弄清楚到底是以何种方式组合在一起的。其英文Array可以更精确地描述其中的相互联系，array本义是指有序的队列。因此，我们指的数组的典型特征是：有序的，数据的集合。
　　很多编程语言中都有数组的这个概念，但都在这个基本定义的基础上进行了各自的扩展。
　　高级编程语言为了提高编程的便利性，增加了特性，如数组中保存不同类型的值（通过保存指向不同类型数据的指针实现，下标从1开始等。），但这样的是运行效率有所降低。引入了多维数组的逻辑概念
　　C++中的数组（特指最常用的一维数组）的特点是：只能存放同类型的数据，保存的是值，下标（索引）时从0开始的。此外，虽然C++从语法形式的角度上定义了多维数组即使是多维数组，也将下标的索引转为对应的偏移值，通常说的多维数组其实是数组的数组。这样，数组以其整齐划一的行列特性，成为C++中独特的风景线。
　　C++中的数组的这些特性，其实是与其出身有关。众所周知，C++是从C语言发展而来的，而C语言更多地用于系统编程的底层。因此，就带有很多适合于底层操作的特性，如下标从0开始，这样计算偏移的适合，就从a0+(n-1)*delta变为了a0+n*delta，减少了计算量，提高了运行效率。这也再一次表明了：在C++的世界中，是效率优先的，其设计思想是：在尽可能不损失运行效率的前提下，提高编程的便利性。
　　但是从底层实现严格来讲，C++里面没有多维数组，如a[i][j]就转换为a[0]+(i-1)*(j-1)。在使用数组的时候，记住这点有利于理解其应用。
　　
4.1 固定的数组大小
　　对于每个数据，程序在运行时就需要分配相应的内存空间。对于数组这个概念，分配效率最高的自然是固定的大小的数组，因此，C++中的数组也沿袭了C语言（C90标准）的做法，数组长度固定不可变，数组的长度是固定的，需要在声明的时候指定好。
int a[buf_size];  //buf_size 为前面定义好的变量
Int a[get_size()]; 
//以上两种声明均错误，变量和函数不能用于定义数组长度。

要保证数组的长度足够容纳需存储的数据大小
 char str[6]=“Hello”;  //注意数组大小并非为5
字符串的末尾默认加上了一个 ‘\0’ 字符，需要一个字符的存储位置。
   一般是估计所存储的数据大小，然后留一定的余量。余量太小不够用，太大则浪费存储空间。



4.2 下标越界问题
可以输出下标超过有效范围的元素，但是修改这个元素会导致未知的错误（举例）

防止 出现 数组下标越界的错误
比如 定义  int a[2]  ,表示a这个数组有两个元素 a[0] a[1]  ,如果程序中对a[2]操作就会出现错误！  此外，也要牢记数组的下标是从0开始的
预设大小   输入参数判别     sizeof(a)/sizeof(int)

const size=10;
int a[size];
for(int i=1;i<=size;i++)
{
    a[i]=i;
}
//注意上面代码中循环条件初始值与截止值的错误！
　　
　　
4.3 数组名的特殊性
数组不能整体输入(举例，只能用for循环)

Int a[5]
Cin>>a[5]


不能用一个数组初始化另外一个数组
int a[3]={1,2,3};
int b[3]=a; 
//因为数组名在某种形式上，相当于常量指针，因此，对数组名赋值表示其它的含义
正确做法：
    for(int i=0;i<3;i++)
  {
     b[i]=a[i]
  }



数组不允许用来作为初始化参数和赋值
	int a[]={1,2,3};
	int b[](a);   //错误，不能用一个数组初始化另外一个数组
	int c(3);
	c=a;    //错误，不能将一个数组赋值给另外一个数组


4.4 数组与循环的黄金组合
　　简洁、高效，这就需要在思考问题的时候转换为这种思维方式。
　　
　　
4.5 数组的排序、查找
　　需要用到这些的问题是如此的频繁，以至于成为了计算机科学的经典问题。
　　常见的排序算法有：冒泡排序、比较法排序。
　　查找有二分查找等
　　
4.6 多维数组
二维数组下标都是从0开始的
　　
　　
常见的多维数组为二维数组 三维数组 
	int a[3][4];  //3行4列
	int(*p)[4]=a;  //参考 int b[4]的语法格式，
　　
　　
输出时利用  %7 换行
对字符数组的输入比较特殊  ，两个字符串的输入

4.7 数组的新变化
随着C++ 2003 的修订、C++ 11标准的实施，数组也迎来了新的变化。
4.8 Vector的引入
c++最新标准（c++ 98 c++ 11） 引入了vector.
Vector的vector，相当于二维数组。、、三位数组
现代 C++ 程序，更多地用vector来替代传统的内置数组，数组被严格限制于类内部使用。只有当性能测试表明无法达到必要的速度要求的时候，才使用数组。
在作为数组循环的指示器时多用迭代器，和可变长度的数组 vector配套使用。
特别地，对于常用的字符串类型，采用string替代C风格的字符串
因此，C99标准引入了 可变长度的数组 （98年的VC6.0不支持）



4.9 Array的引入


4.10 数组的整体操作
在最新 C++ 11标准中，

4.11 标准库中的Tuple







第五章  间接的指针
                                        --------------------- 曲尽其态

　　IT界有一句名言：任何问题都可以通过添加一层来解决！之所以有这句话，是因为层的引入也代表着引入了间接的思想，层的威力其实是间接思想的威力。
　　我们即将介绍的指针和引用这两个概念都很好地体现了间接的思想，他们在C++程序中广泛应用。正确地使用能够很好地解决很多用常规手段难以解决的问题。
　　
隔离变化的指针
　　桌面或者工具栏的快捷方式（如IE、QQ、VC）。
　　不管文件安装在在哪个磁盘或者哪个目录下，都不会影响图标的位置、大小、颜色等属性，用户接口或者体验不变。
　　一般情况下，寄送快递是拨打快递公司官方的400电话或者800电话下单，而不是直接拨打公司的固定电话或者快递员的手机。
　　这种的好处是如果公司办公地址变动，固话的号码会改变，或者快递员离职不再从事快递服务，400电话则不用变动，只需重新对应到新的公司固话或者查询到当前快递员的手机，保证了业务的连续性，也保证了前期广告营销中400电话的继续有效。
　　不过，有时候直接到安装目录去运行exe文件或者直接联系快递员的电话会更直接更方便，比如桌面图标很多或者快递公司官方总机服务占线的时候。
　　这类情况的共同优点是：要隔离易变化的部分，使用户体验保持不变，能够继续享用目标对象相同的功能或者提供的服务，使得灵活性提高很多，所付出的代价是稍微费些周折。 
　　程序设计中的指针就和这些情况和类似。有时候，我们不是直接使用某变量，而是间接地通过另外一个指针变量来访问。指针变量的值是目标对象的地址。目标对象可以是变量、数组、指针甚至函数，只要这个对象是保存在内存中，拥有一个独立的地址。  
　　
殊途同归的引用
　　《水浒》中108好汉都有绰号，我们提到《水浒》中“及时雨”、“黑旋风”时，指的是宋江和李逵。同样，《西游记》中的齐天大圣也是指孙悟空。 
　　为了照顾不同人群的需求、方便直接输入，很多网站采用多个域名策略，这个指网站有好几个域名。如对于谷歌， 输入g.cn 就自动跳转到  google.com.hk 。如果跳转到别的网站，则是指针了。
　　这类情况的共同点是：通过不同的名称，来访问同一个目标对象。
　　同样，程序设计中的“引用”概念就对应这种情况，“引用”中存储的也是目的对象的地址，对“引用”的任何操作，程序自动通过这个地址关联到目的变量，就如同直接对变量本身进行操作，好比让变量具有了一个别名。

5.1 指针的概念
　　我们这里说的指针其实完整的名称是“指针变量”。我们主要从指针的类型和值、指针的运算以及指针的const修饰符等方面来说明符合语法要求的指针基本用法。 
5.1.1 指针的类型和值
对于理解指针，首先需要理解指针的类型和指针的值这两个概念。
5.1.1.1 指针的类型
　　C++中每个变量都有类型，指针变量也不例外。与平时使用的整数变量、字符变量、浮点变量以及自定义类型不同的是，指针的类型表示多了个“*” ，是“数据类型 * ”的形式。而 int* p则表示p是一个指向整数的指针变量，可以简称为整数指针，char * str表示str是一个指向字符的指针变量，简称为字符指针。
　　习惯说，我们在定义指针变量名的时候通常用p ，ptr ，或者pInt 之类的。
　　注意，在C++中，如果是声明多个指针，每个变量前面都必须加上 *，如 Int  * ptr1,* ptr2， 而int *ptr ,ptr; 则相当于int *ptr ,int ptr;
　  由于指针变量是用于存储别的变量的地址，因此，必须能够通过指针对整个内存空间寻址，因此，指针变量本身大小，即占用的内存空间大小是和系统内存字节长相同。对于32位的操作系统，所有类型的指针都是32位的，即4个字节，可以用来存储一个32位的地址。
   可以用sizeof(变量)测出的都是对象自身的类型的大小。

5.1.1.2 指针的值
　　在定义了指针并且初始化后，如int b;  p=b; 或者 new  int(3)，指针就有了一个表示地址的合法值，指向内存区中某个位置。如对于32位的地址 0X125EFA 之类 。但是要注意，为了读取这个位置所存储的值，除了这个首地址，我们还必须知道尾地址，这样才能完整地将这个地址区间的值读取出来。
　　这就需要用到我们声明指针变量时的类型。声明的表达式中，*前面的类型符号实际上是表明了对指针所指向的地址的解释方式，不同的类型解释方式也不一样，比如 int * pointer， *说明从pointer这个指针变量的值表示的地址开始，往后1个int类型的内存位置大小,这个内存区间就是目标对象所占用的内存空间 。而double * pointer，则表示要往后1个double类型的内存位置大小。
　　
Int a;
int *p=&a;  //指针p指向int类型变量a

double b;
double *ptr=&b; //指针ptr指向double类型变量a

Int *pointer=0x135AFE;
count<<sizeof(p)<<end; //12字节
count<<sizeof(ptr)<<endl; //4字节
count<<sizeof(pointer)<<endl; //4字节
　　
　　因此，在声明了指针类型后，指针所指向的内存区就不仅仅是指针的值所代表的那个内存地址单元，而是从该地址开始，长度为sizeof(指针所指向的类型)的一片内存区。
     
5.1.2   指针的运算
   指针能够进行运算，是因为指针中存储的是地址，而地址这种数据类型的本质，使得地址具有运算的能力。
1. 赋值运算
指针支持的运算符有赋值=，这个赋予指针以灵活性。
要注意，不同类型的值不能互相赋值，除非经过强制类型转换。
2. 取地址运算& 与 解析地址运算 *
　　既然指针处理的对象都是内存的地址，那么建立指针的连接和查找连接就是我们常见就有两个操作。C++定义了取地址运算符&，反引用运算符 *，分别是获取变量的地址和获取指针指向的内存单元的值。
　　假设定义了变量a，则&a的运算结果是地址，可以赋值给一个指针，使得指针指向变量a的首地址。   
　　假设定义了指针p，则 *p的运算结果表示它所指向的变量的值。
3. 四则运算
　　指针支持加减以及衍生出来的自增++，自减--。+=运算    -=运算，可以加上或减去一个整数。但很显然，指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，因为指针中存储的值是表示地址的一个整数。
　　int*ptr=a;  
　　ptr+= 5; 
　 
　　在这个例子中，ptr被加上了5，编译器是这样处理的：将指针ptr的值加上5乘sizeof(int)，
相当于将pInt+=5改写为pInt+=5*sizeof(int);在32位操作系统中就是加上了5*4=20。由于地址的单位是字节，故现在的ptr所指向的地址比起加5前的ptr所指向的地址来说，往后移动了20个字节。
　　如果上例中，ptr是被减去5，那么处理过程大同小异，只不过ptr的值是被减去5乘sizeof(int)，新的ptr指向的地址将比原来的ptr所指向的地址往前移动了20个字节。   

　　值得注意的是，指针的乘法和除法在C++中是没有定义的，也是编译器所不允许的。

4. 关系运算
指针的关系运算符包括（  >   <   ==   !=   >=   <=）这几种。

5. 混合运算
将前面介绍的指针的几种运算符混合起来，则可以得到丰富的表达式。

　如常用于循环遍历，输出数组a的值。
	int a[5]={1,2,3,4,5};
	int *p=a;
	for (int i=0;i<5;i++)
	{
		cout<<*(p+i)<<"  ";
	}
运行结果：
1  2  3  4  5 

每次循环都将指针ptr加1，让指针指向数组的的下一个单元。  

5.2 常见的指针形式
　　指针是一种通用的间接的操作手法，因此，它可以和各类内置的数据类型或者用户自定义的类型搭配组合使用。这种组合，使得指针具有了千变万化的能力。


5.3.1 字符指针
　　之所以要把字符指针单列出来，是因为其有很多的特别之处，并且C++做了很多默认的处理。
　　
　　
Char* 类型    string类型

字符串，字符数组，字符指针

字符串 则是以’\0’ （ASCII码  0x 00）为结束字符的字符数组
	char *p;
	cin>>p;

只能是char *p=new char[20] 指定足够固定的大小，或者使用string，或者事先询问需要输入的个数，没法随机输入不同长度的

\0空字符 没法键盘输入，对应的ASCII为0， 可以用cin.get()来判断是否是 空格或者回车。
。
 由于不能通过键盘输入空字符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白（空格、制表符和换行符）来定字符串的界。这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。

cout 对于 char *  的特殊处理
char *p="hello world"; cout<<p<<endl;打印出来的是字符串，而不是地址?????‘
c++为了兼容c语言， c语言中的char*  代表字符串
这个是编译器把它们区分开了，编译器对指向int数组的指针和指向char数组的指针作了区分，调用了不同的函数去输出。

cin使用空白（空格、tab、换行符）来定字符串的界，意味着cin在获取字符数组时只读取一个单词，并自动在结尾添加空字符。
cin.getline(name,len);读取整行，通过回车键输入的换行符来确定输入结尾，但不保存换行符。若len=20，则函数最多读取19个字符，剩下的空间由空字符填充。
而cin.get(name,len)也是读取整行，但它将换行符保留在输入序列中。因此第二次调用get()函数时看到的第一个字符将是换行符，get()将不能跨过此换行符，但可以用不带参数的cin.get()读取换行符，将两个函数拼接起来，如：
cin.get(name,len).get();
get()和getline()的比较：
若使用getline将一行读入数组中，不知道是因为已经读取了整行还是数组已被填满而停止读取；若使用get()函数，只需查看下一个输入字符是不是换行符便可。


字符串输入技巧 
 #include "stdafx.h"
 #include <iostream>
 using namespace std;
 int main(int argc, char* argv[])
  {
     const int ArSize=20;
     char name[ArSize];
     char dessert[ArSize];
 
     cout<<"Enter yout name:\n";
     cin>>name;
     cout<<"Enter your favorite dessert:\n";
     cin>>dessert;
     cout<<"I have some delicious "<<dessert;
     cout<<" for you."<<name<<endl;
     return 0;
 }

注意看下面我运行的输入：
 

      当我输入Alistair Dreeb的时候，甚至没有对“Enter your favorite dessert ”做出反应，程序便把它显示出来了，然后立即显示最后一行。
      cin是如何确定已完成字符串输入的呢？
      由于不能通过键盘输入空字符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白（空格、制表符和换行符）来定字符串的界。这意味着cin在获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串放到数组中，并自动在结尾添加空字符。
      这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它放到name数组中，这把Dreeb留在输入队列中。当cin在输入队列中搜索用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到dessert数组中。
      每次读取一个单词通常不是最好的选择。所以需要采用另一种字符串读取方法。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如cin）提供了一些面向行的类成员函数：getline()和get()。两个函数都读取一行输入，直到到达换行符。然而，随后getline()将丢弃换行符，而get()将换行符保留在输入序列中。
      getline()函数读取整行，使用回车键输入的换行符来确定输入结尾。调用这种方法，使用cin.getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。getline()成员函数在赌气指定数目的字符或遇到换行符时停止读取。getline()函数每次读取一行，通过换行符来确定行尾，但不保存换行符。相反，在存储字符串时，它用空字符来替换换行符。
      get()函数，有几种变体。其中一种变体的工作方式与getline类似，但get并不再读取并丢弃换行符，而是将其留在输入队列中。假设连续两次调用get()：
      cin.get(name, ArSize);
      cin.get(dessert, ArSize);
      由于第一次调用后，换行符将留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get()认为已到达行尾，而没有发现任何可读取的内容。如果不借助于帮助，get()将不能跨过该换行符。幸运的是，get()有一种，不带任何参数的cin.get()调用读取下一个字符（即使是换行符），的变体。因此可以用它来处理换行符，为读取下一行输入做好准备。
      cin.get(name, ArSize);
      cin.get();
      cin.get(dessert, ArSize);
      另一种使用get()的方式是将两个类成员函数拼接起来（合并），如下所示
      cin.get(name, ArSize).get();  //concatenate member functions
      cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get()函数。
      注意：有些C++的老版本没有实现不接受任何参数的get()变体，但实现了接受一个char参数的get()变体。要使用该变体（而不是没有参数get()），需要首先声明一个char变量：
      char ch;
      cin.get(name, ArSize).get(ch);
      getline()使用起来简单些，但get()使得检查错误更简单些。
      当getline()或get()读取空行时，将发送什么情况？
      最初的做法是，下一条输入语句将在前一条getline()或get()结束读取的位置开始读取；但当前的做法是，当get()（不是getline()）读取空行后将设置失效位(failbit)。这意味着接下来的输入将被阻断，但可以用下面的命令恢复输入：
      cin.clear();
      如果输入行的字符数比指定的多，则getline()和get()将把余下的字符留在输入队列中，而getline()还会设置失效位，并关闭后面的输入。
      另一个问题是，输入字符串可能比目标数组长。

更好做法：

一般不要混用C和C++的用法。Cin与string搭配， char *  与 scanf之类搭配。



错误代码：
#include<iostream>
using namespace std;
const max=100;
int main()
{
 char a[max];
 int i=0;
 cin>> a;
 while(a[i]!='\0')
 i++;
 cout<<i;
 return 0;
}

   cin将输入的字符串放到字符数组中，并自动在结尾添加空字符。好比这个语句char a[]="Hello" ，系统会自动在赋值的时候在a这个字符数组的末尾添加一个'\0' .
 
如果将代码中的  cin>> a; 改为了  cin>> a[max], 则只是表示在输入的字符串中读取第1个字符
输入到字符数组的第max+1个元素中去，也就是说已经越界写入了.
,系统在执行  while(a[i]!='\0') 时，从数组开头a[0]一直读到a[max]也没有读到有'\0',会接着往后读，
直到遇到一个内存单元的值为0，也就是'\0' 为止。



 





如果数组越界
、cout把字符数组当做C风格字符串输出；把普通数字数组名当做一个整数输出。
2、cout把字符数组当做C风格字符串输出，它就会去找结束字符'\0'当做字符串的结束。如果你的字符数组中没有字符'\0'，它就会去字符数组后面的内存中寻找字符'\0'，就会输出一些不属于字符数组的东西，比如你看到的类似汉字的东西。


.C风格字符串与标准库类型string不分
int i;
char * ch = "cchars"; //这是C风格字符串,结尾有'\0'
char mch[] = "mchars";   
string str(ch); //string类的构造函数接收ch,并作转化
i = strcmp(ch,str); //error,有人喜欢把string类作参数输入到strcmp等C字符串函数里,肯定会出问题啊.
ch[0] = 'd'; //error,char *ch获取的内存是const,相当于const char *ch= "cchars";无法修改.
mch[0] = 'f'; //ok 


#include <stdio.h>
int main()
{
char *p="abcdef"; //很多书上说：p在栈，“abcdef”在数据区
p[2]='W';
printf(p);
getchar();
return 0;
}
这个程序编译通过，但是问什么程序运行会出错？

另一个：
#include <stdio.h>
int main()
{
char s[]="abcdef";//s在栈，“abcdef”在数据区
s[2]='W';
  printf(s);
getchar();
return 0;
}
这个程序能够正常输出!

如果我们对一个非字符的指针进行操作，方法是这样的：

　　定义：int a=7; int *p=&a;　或者　int a=7; int *p; p=&a;　或者　int a=7; int *p; *p=a;

　　这样定义的原因是因为等号两边的类型必须匹配，int *p=&a;　等号左边定义的是一个指针，指针的内容是地址，所以等号右边也应该是地址，&a就是取空间a的地址，第二种情况　int *p; p=&a;　为什么不是　*p=&a　而是　p=&a;　因为在定义的时候“*”只是说明p是一个指针，而p也是一个变量，不过是储存地址的一种特殊的变量，对于变量使用，我们都是直接使用它的名字，就好象，我们定义个常量 const a=7;　我们要调用它的时候直接使用a就可以了，并不需要带上　const　修饰，这里也一样，用指针变量时并不需要带上“*”，而第三种情况中的“*”和第二种里面是不同的，这里的“*”是取内容符，与之相反的是取地址符“&”，分析一下，第三种情况中，等号左边是*p表示对指针p取内容，它的内容指向内存中的某个已经在开始通过　int *p;　定义好的空间里（比较确切一点的说法是，p在定义的时候，其内容里的地址指向内存中某个未知的空白区域，即未占用，不受保护的内存空间），这个空间里存放的数据类型是整型，所以等号的右边也应该是整型才能匹配，所以是　*p=a;　这里的“*”和定义时候的是不同的，这一点很重要。

　　其实上面的都是些题外话，我要说的其实是关于指针的输出的一些问题。我们利用上面定义好的进行输出操作。

　　输出指针的内容（即所指向空间的地址）：cout<<p<<endl;
　　输出指针所指的内容（即指针内容所描述地址空间中的内容）：cout<<*p<<endl;

　　指针对于字符的处理却有些特殊，和前面的非字符的指针输出处理要分开理解。

　　比如，我们定义一个　char a='A'; char *p=&a; 　如果我们调用上面非字符指针的输出方式，结果如下：
　　方式１　cout<<p<<endl;　结果　A####（＃表示乱码，不可识别）　并不是地址
　　方式２　cout<<*p<<endl;　结果　A　这和非字符的指针情况一样，输出指针指向的内容
　　而且我们直接操作　cout<<&a<<endl;　结果和方式１的结果是完全相同的

　　为什么方式１输出的不是地址呢？这里有一个特殊的处理，虽然这里的p的内容确确实实是一个地址，但是cout操作字符指针的话，它遇到地址，就会直接去寻找这个地址所指向的内容，并把它的空间里的机器数按照字符的规则转化成字符输出，直到遇到“\0”这个操作符才停止。所以我们直接输出p的时候，它先输出‘A’然后再继续读取后面的内存空间知道遇到“\0”，显示结果是“A+乱码”。

　　你肯定会说，为什么要这样呢，这样多不方便呀，其实这么做是有目的的，而且恰恰就是为了方便才这么设置的。因为这样就可以很容易的处理字符串了，而处理字符串是我们在计算机中用得很多的操作。

　　比如我们第一个字符串数组　char a[]="mantou";　a[]在内存中在7个字节，而不是6个，因为在mantou字符串后面还隐藏有一个“\0”，这时我们用　char *p=a;　（这里不用&a是因为，a[]是一个数组，数组名a本身就是一个指针常量）　输出操作　cout<<p<<endl;　这里就不会输出地址，而是直接输出整个mantou字符串，很方便哈，如果我们　cout<<*p<<endl;　结果显示的是m，因为p是指向数组的首元素的地址的，就是指向这里的储存m的空间的地址，所以取p的内容（*p），只能输出一个m哦。

　　虽然通常情况下我们是不需要了解我们的数据地址的，但我也顺便说说，怎么得到字符指针的地址，也可以方便大家对内存地址的分配再做更深入的研究。

　　char a='A'; 　如果这里直接输出　cout<<&a<<endl;　当然是不能输出地址的，原理上面已经说过了，cout遇到字符型地址就会转换成字符输出。我们可以用指针p先取得a的地址（char *p=&a;），但是这样用　cout<<p<<endl;　也并不能得到地址呀，做个小技巧，首先我们知道p中的内容本身就是地址，但是因为它是字符串，我们又不能直接输出它，所以呀，我们可以把指针里的内容（记载的是一个地址数据）强制转化成整型再输出　cout<<(int)p<<endl;　呵呵，这样就得到了这个指针里的内容——十进制型的地址，而我们知道，地址是用十六进制表示的，形式是　0x########　0x后面加8位十六进制数，我们把我们先得到的十进制地址按照地址的表示形式用流操作转化成十六进制就可以了。代码如下：

cout<<"0x"<<setfill('0')<<setw(8)<<setiosflags(ios::uppercase)<<hex<<(int)p<<dec<<setfill(' ')<<endl;  //流控制实现十六进制地址输出
注意不要忘了　#include<iomanip.h>　这个头文件哦


动态二维数组


Cin与string 不兼容 
如何读取一行，再动态数组保存？
Cstring  与 string  的区别 

Strncpy与strcpy的区别


用C/C++输入任意不定长度的字符串
2010-03-26 19:02
#include <stdio.h>
#include <stdlib.h>
#include <conio.h> 
#include <malloc.h>
#define STEP 8    //空间增加的步长.一个字符是1字节，亦即8bit
char * getstr()    //任意长度的字符串输入，返回字符串的首地址.
{
    char *temp, *str=(char *)malloc(STEP);
    int c=0, len=0, times=1, number=0;
    if(!str)
    {
        printf("内存不够,无法开辟字符串空间!");
        return (char *)NULL;
    }
    number+=times*STEP;
    while((c=getche())!='\r')   //遇到回车则输入结束。
    {
        if(len==number)
        {
            times++;
            number=times*STEP;
            temp=str;    
            str=(char *)realloc(str,number);
            if(str==NULL)
            {
                printf("内存不够，字符串输入受限!");
                str=temp; 
                break;
            }
        }
        *(str+len)=c;
        len++;
    }   
    str=(char *)realloc(str,len+1); //字符串的实际长短调整空间.
    *(str+len)='\0';
    return str;
}
int main()
{
    char *str=NULL;
    str=getstr();     //字符串输入
    printf("\nstr=%s\n",str);
    free(str);   
system("pause");
    return 0;
}
 
 
 
如果光是输入输出是很简单的，但是严格的不定长用C实现起来却不是这么容易，需要一个一个字符读入，然后动态分配内存。楼上的定义一个长度为1000的缓冲区严格意义不符合LZ的要求，超过1000个字符就不行了。

用C++倒是会很容易，stl的string模板类自己动态管理内存的：

#include <iostram>
#include <string>

using namespace std;

int main()
{
    string str;
    cin>>str;  //多长都不会有问题，只要内存足够。
} 





字符指针 

 
开始之前必须明确strlen的含义，原型为size_t strlen( char *str ); strlen返回字符串的长度，即null(\0)之前的字符的数量。
一 char* 与 char []
实例加注释：
Code 
void TestCharPointerAndArray() 
{ 
    char *c1 = "abc"; //abc\0常量区，c1在栈上, 常量区程序结束后自动释放。 
    //c1[1] = 'g'; // 常量不能修改 
    int i = strlen(c1); // 3 

    char c2[] = "abc"; // c2，abc\0都在栈上 
    c2[1] = 'g'; // 可以修改 
    int j = strlen(c2); // 3 
    int jj = sizeof(c2); // 4 

    char *c3 = ( char* )malloc(4* sizeof(char)); // c3 栈上 
    memcpy(c3,"abc",4); // abc\0 在堆上, 4 = 3(strlen("abc")) + 1('\0'); 
    c3[1] = 'g'; // 可以修改 
    int x = strlen(c3); // 3 
    free(c3); //如果这里不free，会内存泄漏 
    c3 = "abc"; // abc\0 在常量区，c3指向了常量区 
    //c3[1] = 'g'; // 常量不能修改 
    int y = strlen(c3); // 3 
} 
复制代码
 
字符串都以\0结尾，所以例如：char *c1 = "abc";char c2[] = "abc";，使用strlen得到长度都为3，但是实际的存储空间为strlen+1即3+1。
二 C中字符串操作函数
C++的程序员对C中的字符串指针操作的函数却并不是相当的熟悉。而C中的这些字符串的指针操作函数有的时候也是必须要面对的，比如我们的库要提供C函数接口，保持向后兼容和跨平台，还有我们经常使用一些第三方的库中都或多或少的使用到了这些C中的指针操作函数，所以下面列出C的指针操作函数，帮助大家熟悉之。
1) memcpy/memset/memcmp
 
    memcpy原型：extern void *memcpy( void *to, const void *from, size_t count ); 
包含：#include <string.h> 或<string>或<cstring> 
功能：由src所指内存区域复制count个字节到dest所指内存区域。 
说明：src和dest所指内存区域不能重叠，函数返回指向dest的指针。 
    memset原型：extern void* memset( void* buffer, int ch, size_t count ); 
包含：#include <string.h> 或<string>或<cstring> 
功能：把buffer所指内存区域的前count个字节设置成字符c。 
说明：返回指向buffer的指针。 
 
   memcmp原型：extern int memcmp(const void *buffer1, const void *buffer2, size_t count ); 
包含：#include <string.h> 或<string>或<cstring> 
功能：比较内存区域buf1和buf2的前count个字节。 
说明： 
        当buf1<buf2时，返回值<0 
        当buf1=buf2时，返回值=0 
        当buf1>buf2时，返回值>0

    memchr 原型： extern void *memchr( const void *buffer, int ch, size_t count ); 
包含：#include <string.h> 或<string>或<cstring> 
功能：查找ch在buffer中第一次出现的位置。 
说明：如果发现返回指针，如果没有返回NULL。  
实例：
 
Code 
void TestMemFunction() 
{ 
    char *s1="Hello!"; // Hello!\0 
    int l = strlen(s1); // 6 
    char *d1 = new char[l+1]; // d1 需要strlen(s1) + 1 空间 
    memcpy(d1,s1,l+1); 

    memcpy(d1,d1,l); 

    memmove(d1 + 1,d1,l-1); 

    const int ARRAY_LENGTH = 5; 
    char the_array[ARRAY_LENGTH]; 
    // zero out the contents of the_array 
    memset( the_array, 'c', ARRAY_LENGTH ); 

    char *a1 = "source1"; 
    char arr1[8] = "source2"; 
    int r = memcmp(a1,arr1,strlen(a1) - 1); // 仅比较source，所以相等 

    char str[17]; 
    char *ptr; 
    strcpy(str, "This is a string"); 
    ptr = (char*)memchr(str, 'r', strlen(str)); 
} 
复制代码
 
2) strlen/strcpy/strcat/strcmp/strchr/strcoll/strstr/strtok/strtod/strtol

strcpychar *strcpy(char *s1, const char *s2) 将字符串s2复制到字符串数组s1中，返回s1的值
strcatchar *strcat(char *s1, const char *s2) 
将字符串s2添加到字符串s1的后面。s2的第一个字符重定义s1的null终止符。返回s1的值

strcmpint strcmp(const char *s1, const char *s2) 
比较字符串s1和字符串s2。函数在s1等于、小于或大于s2时分别返回0、小于0或者大于0的值strchrchar *strchr(char * str,int c ); 在str中查找c第一次出现的位置。strstrchar *strstr(char *str,const char *strSearch );在string1中查找string2第一次出现的位置。strtokchar *strtok(char *strToken,const char *strDelimit ); 分割字符串。 
实例：
 
Code
void TestStrFunction()
{
    char string[11];
    char *str1 = "123456789"; // 123456789\0
    strcpy(string, str1);

    strcat(string,"A"); //123456789A\0

    int r = strcmp(string,"123456789B"); // 123456789A\0 < 123456789B\0
}

void TestStrFunction2()
{
    int  ch = 'r';
    char string[] = "The quick # brown dog # jumps over # the lazy fox";
    char *pdest = NULL;
    pdest = strchr( string, ch );

    pdest = NULL;
    char * str = "dog";
    pdest = strstr(string,str);

    pdest = NULL;
    char delims[] = "#";
    pdest = strtok( string, delims );
    while( pdest != NULL ) 
    {
        pdest = strtok( NULL, delims );
    }
} 
复制代码
 
总结：
1）以mem开始的函数用来bytes的操作，所以需要指定长度，但是以str用来操作以\0结尾的字符串，不需要指定长度。
2）对于unicode，相应的字符串操作函数前缀为wcs，例如wcscpy,wcscat,wcscmp，wcschr，wcsstr，wcstok等。
3）在vc中还提供了有安全检测的字符串函数后缀_s,例如strcpy_s,strcat_s,strcmp_s,wcscpy_s,wcscat_s,wcscmp_s等。
4）char*如果指向常量区，不能被修改，且此char*不需要delete。例如 char* pStr = "ABC";。
三 std::string和std::wstring使用相当简单哦！



5.3.2 指向结构体的指针
　　可以声明一个指向结构类型对象的指针。   
　　　　例十一：   
　　structMyStruct   
　　{   
　　　inta;   
　　　intb;   
　　　intc;   
　　}   
　　MyStructss={20,30,40}; 
　　//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。   
　　MyStruct*ptr=&ss; 
　　//声明了一个指向结构对象ss的指针。它的类型是MyStruct*,它指向的类型是MyStruct。   
　　int*pstr=(int*)&ss; 
　　//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。 
　　　　请问怎样通过指针ptr来访问ss的三个成员变量？   
　　　　答案：   
　　ptr-> a;   
　　ptr-> b;   
　　ptr-> c;   
　　　　又请问怎样通过指针pstr来访问ss的三个成员变量？   
　　　　答案：   
　　*pstr；//访问了ss的成员a。   
　　*(pstr+1);//访问了ss的成员b。   
　　*(pstr+2)//访问了ss的成员c。   
　　　　虽然我在我的MSVC++6.0上调式过上述代码，但是要知道，这样使用pstr来访问结构成员是不正规的，为了说明为什么不正规，让我们看看怎样通过指针来访问数组的各个单元：   
　　　　例十二：   
　　intarray[3]={35,56,37};   
　　int*pa=array;   
　　　　通过指针pa访问数组array的三个单元的方法是：   
　　*pa;//访问了第0号单元   
　　*(pa+1);//访问了第1号单元   
　　*(pa+2);//访问了第2号单元  
　　
　　从格式上看倒是与通过指针访问结构成员的不正规方法的格式一样。   
　　　　所有的C/C++编译器在排列数组的单元时，总是把各个数组单元存放在连续的存储区里，单元和单元之间没有空隙。但在存放结构对象的各个成员时，在某种编译环境下，可能会需要字对齐或双字对齐或者是别的什么对齐，需要在相邻两个成员之间加若干个 "填充字节 "，这就导致各个成员之间可能会有若干个字节的空隙。   
　　　　所以，在例十二中，即使*pstr访问到了结构对象ss的第一个成员变量a，也不能保证*(pstr+1)就一定能访问到结构成员b。因为成员a和成员b之间可能会有若干填充字节，说不定*(pstr+1)就正好访问到了这些填充字节呢。这也证明了指针的灵活性。要是你的目的就是想看看各个结构成员之间到底有没有填充字节，嘿，这倒是个不错的方法。   
过指针访问结构成员的正确方法应该是象例十二中使用指针ptr的方法。




5.3.3 空指针 void  *
　　现代操作系统会保留从0开始的一块内存（因为操作系统的内存管理方式一般是基于页面的管理，因此无法只保留1个字节，只能至少保留1个页面），程序不允许访问。
   不能对 Void *类型的指针使用*  来取得其指向的变量，因为用*的时候要确保指针是指向一个有效的地址。
   此外，void* 类型的指针不能参加数学运算，只能进行赋值、比较和sizeof()操作。


Void *  指针的应用  实现多态
另类的指针家族成员—— void *。不要按照通常的命名方式叫它做指向 void 类型的指针，它的正式的名字叫做：可以指向任意类型的指针。


指针变量要和NULL进行比较，不要和布尔型和整形比较


指针参数是如何传递内存的？
如果函数的参数是一个指针，不要指望用该指针去申请动态内存

Test 函数的语句GetMemory(str, 200)并没有使str 获得期望的内存，str 依旧是NULL，
为什么？
void GetMemory(char *p, int num)
{
p = (char *)malloc(sizeof(char) * num);
}
void Test(void)
{
char *str = NULL;
GetMemory(str, 100); // str 仍然为 NULL
strcpy(str, "hello"); // 运行错误
}
毛病出在函数GetMemory 中。编译器总是要为函数的每个参数制作临时副本，指针
参数p 的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p 的内容，就导致
参数p 的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p 申请
了新的内存，只是把_p 所指的内存地址改变了，但是p 丝毫未变。所以函数GetMemory
并不能输出任何东西。事实上，每执行一次GetMemory 就会泄露一块内存，因为没有用
free 释放内存。
如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”
void GetMemory2(char **p, int num)
{
*p = (char *)malloc(sizeof(char) * num);
}
void Test2(void)
{
char *str = NULL;
GetMemory2(&str, 100); // 注意参数是 &str，而不是str
strcpy(str, "hello");
cout<< str << endl;
free(str);
}
由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态
内存。这种方法更加简单
char *GetMemory3(int num)
{
char *p = (char *)malloc(sizeof(char) * num);
return p;
}
void Test3(void)
{
char *str = NULL;
str = GetMemory3(100);
strcpy(str, "hello");
cout<< str << endl;
free(str);
}
用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return 语句用错
了。这里强调不要用return 语句返回指向“栈内存”的指针，因为该内存在函数结束时
自动消亡
char *GetString(void)
{
char p[] = "hello world";
return p; // 编译器将提出警告
}
void Test4(void)
{
char *str = NULL;
str = GetString(); // str 的内容是垃圾
cout<< str << endl;
}
用调试器逐步跟踪Test4，发现执行str = GetString 语句后str 不再是NULL 指针，
但是str 的内容不是“hello world”而是垃圾。
char *GetString2(void)
{
char *p = "hello world";
return p;
}
void Test5(void)
{
char *str = NULL;
str = GetString2();
cout<< str << endl;
}
函数Test5 运行虽然不会出错，但是函数GetString2 的设计概念却是错误的。因为
GetString2 内的“hello world”是常量字符串，位于静态存储区，它在程序生命期内
恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。


5.3.4 指针的const修饰符
　　Const 是用在程序中表示常量属性的，根据const和*的位置，可以表示声明的变量是常量指针（指向const对象）的指针还是指针常量（const指针）。
1. 指向 const对象的指针 
　　对于const int *p这类指针，我们称之为常量指针，含义表述为“指向常量的指针”，它首先应该是一个指针。就是说我们定义了一个常量，比如　const int a=7;　 如果我们希望用指针对这个常量进行操作，那么我们就需要定义一个常量指针来指向它　const int *p=&a;　也可以分成两步，即　const int *p; p=&a;
　　我们可以将const和右边紧挨着的int看作一个整体，表示一个int类型const对象，即 const只是限定了指针p所指向的类型，由于const属性的值是不能被修改的，因此，我们不能通过p修改所指向对象的值。
　　
　　
　　　int a=0; p=&a;    //可以。
　　　*p=20;          //不可以。 
　　　Int b; 
　　　p=b;   //ok，可以给p重新赋值，使其指向另一个const对象。
　　　const int b=10;
       int *p2=&b; //error，不能把const对象的地址赋给一个不是指向const对象的指针
      const int *p3=&b; //ok

　　在编程中，如果我们试图修改常量指针的所指向的变量的值，编译系统就会提示出错。这也是防御编程的方式，防止无意中出错。

2. const指针 
　　对于int *   const  p 这声明了一个指针常量，表述为“是指针的常量”，它首先应该是一个常量。它和指向const对象的指针恰好相反，它不能够修改所指向对象，但却能够修改指向对象的数值。指针的内容实际是一个地址，那么指针常量就是内容不能修改的常量。就是不能修改这个指针所指向的地址，一开始初始化，指向哪儿，它就只能指向哪儿了，不能指向其他的地方了，但这个指向的地方里的内容是可以修改的。int a; int * const p=&a;　也可以分开写　int a; int * const p; p=&a。
　
　另外，这种指针在声明时必须初始化。
　
　　int c=20;
　　int *const p4=&c;
　　
3. 指向const对象的const指针
　　前面我们分别指出了指针常量和常量指针。当然，你也可以定义个一个指向常量的指针常量，就把上面的两个综合一下，表示如下：
　　const int a=7; const int * const p=&a;
　　指针p既不能修改指向的对象，也不能修改只想对象的值。



5.3.5 数组名的指针本质
数组名相当于常量指针，即const int 类型。


     指针与数组的特性比较：
	  /*修改指针和数组的内容*/
 char a[]="hello"; //数组a的容量是6个字符，内容为hello\0
 a[0]='X'; //a的内容可以改变

  /*内容复制和比较*/
 char a[]="hello";
 char b[10];
 strcpy(b,a); //不能用b=a;否则产生编译错误
 if(strcmp(b,a)==0) //不能用if(b==a)
 
 int len=strlen(a);  //strlen字符串的长度，不包括'\0'
 char *p=(char *)malloc(sizeof(char)*(len+1));
 strcpy(p,a); //不要用p=a; p=a是把a的地址赋给了p，要想复制a的内容，可以先用库函数
              //malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制
 if(strcmp(p,a)==0) //不能用if(b==a),它比较的是地址，不是内容
 
  /*计算内存容量*/
 char a[]="hello world";
 char *p=a;
 cout<<sizeof(a)<<endl; //12字节，sizeof计算数组的容量，包括'\0'
 cout<<sizeof(p)<<endl; //4字节
 
 void Func(char a[100])
  {
     cout<<sizeof(a)<<endl; //4字节而不是100字节，数组作函数参数传递时，自动退化为同类型的指针
 }
	C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。 
	
 
	下面以字符串为例比较指针与数组的特性。 
	1 修改内容 
	下例中，字符数组a的容量是6个字符，其内容为hello。a的内容可以改变，如a[0]= 'x'。指针p指向常量字符串"world"（位于静态存储区，内容为world），常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句 p[0]= 'x'有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。
	 #include<iostream.h>
 
 void main()
  {
     char a[] = "hello";
     a[0] = 'x';
     cout << a << endl;
     char *p = "world"; // 注意p指向常量字符串
     p[0] = 'x'; // 编译器不能发现该错误
     cout << p << endl;
 }
	2 内容复制与比较 
	不能对数组名进行直接复制与比较。下例中，若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。 
	语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。
// 数组…
 char a[] = "hello";
 char b[10];
 strcpy(b, a); // 不能用 b = a;
 if(strcmp(b, a) == 0) // 不能用 if (b == a)
 …
 // 指针…
 int len = strlen(a);
 char *p = (char *)malloc(sizeof(char)*(len+1));
 strcpy(p,a); // 不要用 p = a;
 if(strcmp(p, a) == 0) // 不要用 if (p == a)
 …
	 3 计算内存容量 
	用运算符sizeof可以计算出数组的容量（字节数）。下例(a)中，sizeof(a)的值是12（注意别忘了' '）。指针p指向a，但是 sizeof(p)的值却是4。这是因为sizeof(p)得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。 C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。下例(b)中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。 
	示例(a)
	 char a[] = "hello world";
 char *p = a;
 cout<< sizeof(a) << endl; // 12字节
 cout<< sizeof(p) << endl; // 4字节
示例(b)
	 void Func(char a[100])
   {
 　cout<< sizeof(a) << endl; // 4字节而不是100字节
 }
	
　数组的数组名其实可以看作一个指针。看下例：   
　　例八：   
intarray[10]={0,1,2,3,4,5,6,7,8,9},value;   
...   
...   
value=array[0];//也可写成：value=*array;   
value=array[3];//也可写成：value=*(array+3);   
value=array[4];//也可写成：value=*(array+4); 
上例中，一般而言数组名array代表数组本身，类型是int[10]，但如果把array看做指针的话，它指向数组的第0个单元，类型是int*，所指向的类型是数组单元的类型即int。因此*array等于0就一点也不奇怪了。同理，array+3是一个指向数组第3个单元的指针，所以*(array+3)等于3。其它依此类推。   

　　例九：   
char*str[3]={   
　 "Hello,thisisasample! ",   
　 "Hi,goodmorning. ",   
　 "Helloworld "   
};   
chars[80]；   
strcpy(s,str[0]);//也可写成strcpy(s,*str);   
strcpy(s,str[1]);//也可写成strcpy(s,*(str+1));   
strcpy(s,str[2]);//也可写成strcpy(s,*(str+2)); 
上例中，str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串。把指针数组名str当作一个指针的话，它指向数组的第0号单元，它的类型是char**，它指向的类型是char*。   
*str也是一个指针，它的类型是char*，它所指向的类型是char，它指向的地址是字符串 "Hello,thisisasample! "的第一个字符的地址，即 'H '的地址。   str+1也是一个指针，它指向数组的第1号单元，它的类型是char**，它指向的类型是char*。   

　　*(str+1)也是一个指针，它的类型是char*，它所指向的类型是char，它指向   "Hi,goodmorning. "的第一个字符 'H '，等等。   

　　下面总结一下数组的数组名的问题。声明了一个数组TYPEarray[n]，则数组名称array就有了两重含义：第一，它代表整个数组，它的类型是TYPE[n]；第二   ，它是一个指针，该指针的类型是TYPE*，该指针指向的类型是TYPE，也就是数组单元的类型，该指针指向的内存区就是数组第0号单元，该指针自己占有单独的内存区，注意它和数组第0号单元占据的内存区是不同的。该指针的值是不能修改的，即类似array++的表达式是错误的。   
　　在不同的表达式中数组名array可以扮演不同的角色。   
　　在表达式sizeof(array)中，数组名array代表数组本身，故这时sizeof函数测出的是整个数组的大小。   
在表达式*array中，array扮演的是指针，因此这个表达式的结果就是数组第0号单元的值。sizeof(*array)测出的是数组单元的大小。   
　　表达式array+n（其中n=0，1，2，....。）中，array扮演的是指针，故array+n的结果是一个指针，它的类型是TYPE*，它指向的类型是TYPE，它指向数组第n号单元。故sizeof(array+n)测出的是指针类型的大小。   
例十 
intarray[10];   
int(*ptr)[10];   
ptr=&array;：   
上例中ptr是一个指针，它的类型是int(*)[10]，他指向的类型是int[10]   ，我们用整个数组的首地址来初始化它。在语句ptr=&array中，array代表数组本身。   

　
Int a[2][3]={1,2,4,6,8,11 }
Cout<<*(*(a+i)+j)


A[2][3]中Char **  与 char(*p)[4] 类型不能转换
如何使用 **  ?
Int a[2][3]={1,2,4,6,8,11 }
Int ** p=a;   //错误！

　　只有这样才能保证++p使p指向a的下一对像（该对像是一个数组）。
　　顺便提一句：不要写成“int *p[4];”



5.3 指针的组合使用
组合使用指针，可以达到变化无穷的，极度灵活解决问题。甚至是构成了编程的基础。


5.3.1 数组的指针
sizeof(int(*)[10])==4   
sizeof(int[10])==40   

而且，在函数中，数组参数退化为指针，所以下面的内容永远输出为4 
void fun(char a[1000])
{
count<<sizeof(a)<<endl; //输出4而不是1000
}


4、释放内存时，如果是数组指针，必须要释放掉所有的内存，如 
char *p=new char[100];
strcpy(p,”Hello World”);
delete []p; //注意前面的［］号
p=NULL;
5、数组指针的内容不能超过数组指针的最大容易。
如: 
char *p=new char[5];
strcpy(p,”Hello World”); //报错 目标容易不够大
delete []p; //注意前面的［］号
p=NULL;
数组与指针
C++的数组经常需要和指针来结合使用，下面来进行相关的强化训练。实例如下：
 
Code
#pragma once
#include <iostream>
using namespace std;

void PrintArray(double *p, int num)
{
    for(int i = 0; i < num; ++i)
    {
        cout << " " << p[i] << " ";
    }
    cout << endl << "The array is end!" << endl;
}
void PrintArray(double arr[3]) 
{
    for(int i = 0; i < 3; ++i)
    {
        cout << " " << *(arr+i)/*arr[i]*/ << " ";
    }
    cout << endl << "The array is end!" << endl;
}
void ChangeArray(double arr[3]) // 数组传参为传指针，所以函数内可以修改
{
    for(int i = 0; i < 3; ++i)
    {
        arr[i] = 10;
    }
}
void PrintArray(double arr[3][3])
{
    for(int i = 0; i < 3; ++i)
        for(int j = 0; j < 3; ++j)
            cout << " " << arr[i][j] << " ";
    cout << endl << "The array is end!" << endl;
}

int GetLength(){return 3;}

void TestArray()
{
    // 数组的定义和初始化
    short months[12] = {31,28,31,30,31,30,31,31,30,31,30,31};
    double arr[3]; 
    arr[0] = 1.0;
    arr[1] = 2.0;
    arr[2] = 3.0;
    double arr2[] = {1.0,2.0,3.0};
    //double arr3[3] = arr; // error
    PrintArray(arr,3);
    PrintArray(&arr[0],3);
    PrintArray(arr2);

    double matrix2 [2][2] = {1.0,0.0,0.0,1.0};
    double matrix3 [3][3] = {{1.0,0.0,0.0},
                            {0.0,1.0,0.0},
                            {0.0,0.0,1.0}};
    PrintArray(matrix3[0],3*3);
    PrintArray(&matrix3[0][0],3*3);
    //PrintArray(matrix3,3*3);
    PrintArray(matrix3);

    // 指针来模拟数组
    double *p3 = new double[GetLength()];
    p3[0] = 10.0;
    p3[1] = 20.0;
    p3[2] = 30.0;
    PrintArray(p3,3);
    PrintArray(p3);
    delete []p3;

    // 数组+指针实现二维变长数组
    double *p4[2];
    p4[0] = new double[2];
    p4[1] = new double[4];
    p4[0][0] = 10;
    p4[0][1] = 20;
    p4[1][0] = 30;
    p4[1][1] = 40;
    p4[1][2] = 50;
    p4[1][3] = 60;
    PrintArray(p4[0],2);
    PrintArray(p4[1],4);
    delete [] p4[0];
    delete [] p4[1];

    PrintArray(arr); // 数组传参为传指针，所以函数内可以修改
    ChangeArray(arr);
    PrintArray(arr);
} 
复制代码
 
代码分析总结：
1）数组的定义必须使用常量指定长度，例如：double arr[3]，但是使用指针时可以是运行时指定，例如double *p3 = new double[getLength()]。
2）数组定义时即分配空间且在栈上，不需要程序员来对内存管理，但是如果对指针使用了new[]，则必须由程序员在使用完毕后delete[]。
3) 一维数组数组名即第一个元素的地址，例如：double arr[3]中，arr == &arr[0]为true。
4）二维数组中第一行的地址即为第一个元素的地址，例如：double matrix3 [3][3]，matrix[0] == &matrix[0][0]为true。
5）可以使用指针数组来模拟变长二维数组，例如：double *p4[2]; p4[0] = new double[2]; p4[1] = new double[4];
6）二维数组内存中同一维数组仍为连续的区域，所以可以将二维数组和一维相互转化。
7）一维数组名即为第一个元素的地址，所以可以同指针隐式转化，但二维数组名不是第一个元素地址，所以不能转化。
8) 当函数传入数组，实际传首元素的指针，所以可以在函数内修改数组元素。








　  int (*p)[2]; 声明了一个指针， 指向了一个有两个int元素的数组。
　同理，数组指针也可以作类似处理：
    typedef int intArray2[2];
    intArray2 * p;
　
　
讲到第五章了，数组两个字还离不开我们的左右，数组的内容也真多，另一方面也因为数组与指针的关系的确非常密切。 
        通常，对于int a[8][9]这个二维数组，我们可以这样定义一个指向它的指针：
int (*p)[9];
这个声明的形式跟人们所熟悉的int *p的形式大相庭径，初学者通常会感到迷惑，不理解的地方大致有四个：
1。为什么会以这种形式声明？
2。(*p)应该如何理解？
3。为什么必须把第二维显式地声明？
4。为什么忽略第一维？
下面我们就一起逐个讨论这四个问题：
1。这种形式是C标准的声明语法规定的，由于本章不是对标准的解释，只是对标准的应用，因此笔者尽量以简洁的方式解释这个声明，详细的讨论将在第七章进行。C标准的声明包含了两部分：
声明：
声明说明符  初始化声明符表opt      (opt的意思是可选)
在声明说明符里面有一项类型说明符，int就是这种类型说明符。而初始化声明符表里面的其中一种形式，就是：
直接声明符 [常量表达式opt]
(*p)[9]就是这种直接声明符加[]的形式。
2。p左边的*在这里不是取值运算符，而是一个声明符，它指出p是一个指针。而()括号是不能去掉的，如果去掉了，由于[]运算符优先级比*高，p就会先跟[]结合，这样p就变成了一个指针数组，而不是指向数组的指针。
题外话：
*p还有一种用法，就是当*是取值运算符的时候，*p是一个左值，表示一个变量，为什么*p是一个变量呢？也许有人会说，因为int i, *p=&i嘛，其实这是结果不是原因。严格来说，i只是一个变量名，不是变量，在编译器的符号表里面，变量名是一个符号地址，它所代表的地址值是它指向的那段内存单元的地址，真正叫变量的是那段内存单元，懂汇编的朋友能很容易地区分出来，在汇编里面，可以这样定义一个变量名：
VARW  DW  10,20
VARW就是一个变量名，它在汇编里面是一个地址，代表了10所在的内存单元这个变量。由于p被初始化为&i，*p指向i所代表的那段内存单元，因此说*p是一个变量。把i称为变量是一种习惯上的统称。
3。定义一个指针的时候，首先必须定出指针的类型，由于这是一个指向数组的指针，如果数组的元素的类型定下来了，那么这个指针的类型也就定下来了。前面说过，C语言的多维数组实质上是数组的嵌套，那么所指向数组的元素必定具有数组类型，也就是说，这个数组的元素是一个具有6个int元素的数组，因此，p定义的时候，必须指定第二维的上界，这样才能把p的类型定下来。
4。有这种疑问的人已经犯了一个错误，没有分清楚什么是指针，什么是数组，以数组的思维模式来看待这个指针p。定义一个数组（非static）的时候，需要在栈中静态分配一块内存，那么就需要知道这块内存的大小，因此定义数组时需要确定各维的上界。而这里只是定义一个指针而已，对于一个指针的定义，需要知道的是它所指向对象的类型，并不需要知道对象的大小，这是多余的。因此，所有指向数组的指针的第一维被忽略。
        以上介绍了如何声明一个指向二维数组的指针，类似地，对一个指向n维数组的指针也可以用同样的方法来声明，如下：
int (*p)[x2][x3]......[xn];
同样可以忽略第一维，而其它维必须指定上界。
        最后再讨论一种很常见的对多维数组的错误理解，有些人常常会以为，二维数组就是二级指针，这种错误的根源，来自于可以把一个二级指针int **p以p[i][j]这种形式使用。首先把数组称为指针就是错误的，第一章笔者已经说明了数组名是地址，不能理解为指针。第二，并非能以p[i][j]这种形式使用，那么p就是一个二维数组了，C标准对数组引用的规定，并没有指定数组引用时[]运算符的左边必须是数组名，而可以是一个表达式。第三，这是一种“巧合”，归根到底是由于C语言的数组实现是数组的嵌套同时C标准把[]运算符转换为类似*(*(a+i)+j)这样的等价表达式造成的，那两个取值运算符“恰好”可以用于一个二级指针。第四，p与p[i]并不具有数组类型，sizeof(p)和sizeof(p[i])的结果只是一个指针的大小4字节。而对于一个真正的数组，p与p[i]都是具有数组类型的地址。
        实际上，int **p只是一个指向一维指针数组的指针，而不是指向二维数组的指针。同样地，对于n级指针，都可以看作一个指向一维指针数组的指针，这个指针数组的元素都是n-1级指针。
　
　
　
　
　还有两类情况，也可以归属于通过指针来操作数组的形式：
　动态数组 
　　
　　
　　数组名与指针
　　在数组int a[5] 中，数组名 在某种程度上相当于常量指针int *  const  a,因此不能给数组名赋新的值。试图使得数组名指向别的地方时错误的，但是可以把数组名赋值给指向变量，然后改变指针变量
　　Int a[5]
　　While(a!=0)
　　    a++；  //错误
　　
　　int *p;
　　p=a;
　　while(*p!=0)
　　   p++;     //正确 
　　
　　数组名虽然相当于常量指针，但它是一种受限制的指针，所指向的地址和内存容量都是在定义的时候由不变，只有数组的内容可以变。而指针则可以指向任意类型的内存。指针远比数组灵活，权限更大，但也更危险。
　　
　　
二维数组名  等价于指向一维数组的指针 
Int b[3][4]   int(* const b) [4]
Int b[3][4][5]   int(* const b) [4][5]

下面四种等价
　　		a[i][j]
　　		*(a[i]+j)
　　		(*(a+i))[j]
		*(*(a+i)+j)   改写为 （（a+i*sizeof(int)*n+j*sizeof(int)）

int * b=new int[10];　指向一维数组的指针b ; 
注意，这个时候释放空间一定要delete [] ,否则会造成内存泄露， b 就成为了空悬指针. 

int (*b2)[10]=new int[10][10]; 注意，这里的b2指向了一个二维int型数组的首地址. 
注意：在这里，b2等效于二维数组名，但没有指出其边界，即最高维的元素数量，但是它的最低维数的元素数量必须要指定！就像指向字符的指针，即等效一个字符串,不要把指向字符的指针说成指向字符串的指针。这与数组的嵌套定义相一致。 
int(*b3) [30] [20];  //三级指针――>指向三维数组的指针； 
int (*b2) [20];     //二级指针； 
b3=new int [1] [20] [30]; 
b2=new int [30] [20]; 
      两个数组都是由600个整数组成，前者是只有一个元素的三维数组，每个元素为30行20列的二维数组，而另一个是有30个元素的二维数组，每个元素为20个元素的一维数组。 
      删除这两个动态数组可用下式： 
delete [] b3;  //删除（释放）三维数组； 
delete [] b2;  //删除（释放）二维数组； 
再次重申：这里的b2的类型是int (*) ，这样表示一个指向二维数组的指针。 
b3表示一个指向（指向二维数组的指针）的指针，也就是三级指针.











数组的数组与多维数组的区别 
分类： 再再论指针 2005-09-17 16:14 5313人阅读 评论(18) 收藏 举报 
        看见这个题目，也许有些人就会嘀咕了：难道两者不是一样的吗？C语言的多维数组不就是数组的数组吗？不！两者是有区别的，而且还不小呢。首先看看两者的共同点：
1。内存映象一样。
2。数组引用方式一样，都是“数组名[下标][下标]........”。
3。数组名都是数组的首地址，都是一个符号地址常量、一个右值。

        由于两者的共同点主要反映在外部表现形式上，因此，从外部看来，数组的数组跟多维数组似乎是一样的，这造成了C程序员对两者的区别长期以来模糊不清。但实际上，c语言限于本身的语言特性，实现的并非真正的多维数组，而是数组的数组。
        数组的数组与多维数组的主要区别，就在于数组的数组各维之间的内在关系是一种鲜明的层级关系。上一维把下一维看作下一级数组，也就是数组嵌套。数组引用时需要层层解析，直到最后一维。举个例，对于数组：
int a[7][8][9]；
如果要访问元素a[4][5][6]，首先就要计算第一维元素4的地址，也就是a+4，由于是数组的数组，元素4的值代表了一个数组，因此元素4的值就是它所代表的那个数组的首地址，我们用一个符号address1代表它，也就是address1=*(a+4)，接着计算第二维，显然元素5的地址是address1+5，其值也是一个数组的首地址，用address2表示它，就是address2=*(address1+5)，最后一维，由于已经到达了具体的元素，因此这个元素的地址是address2+6，其值*(address2+6)是一个整数，把address1和address2分别代入相应表达式，就成了：
*(*(*(a+4)+5)+6);
这就是我们熟知的[]运算符的等价表达式。 
        而真正的多维数组并没有这么多“束缚”，相比之下简单得多，由于各维之间不是这种复杂的层级关系，元素a[4][5][6]的偏移量可以这样直接获得：(4x8x9+5x9+6)xsizeof(int)，再加上数组的首地址a就是元素a[4][5][6]的地址了。但是，c语言的数组能够这样用首地址加上(4x8x9+5x9+6)xsizeof(int)的形式来访问元素吗？显然是不行的。归根到底就在于C语言的地址数据类型不但有类型，还具有级别。就是这种层级关系造成了C语言只能用数组的数组当作多维数组。如果C语言非得要实现真正的多维数组，那么地址与指针的概念就得重新改写了。

指向二维数组的指针
2009-12-21 19:36
一. 二维数组元素的地址 
    为了说明问题, 我们定义以下二维数组: 
     int a[3][4]={{0,1,2,3}, {4,5,6,7}, {8,9,10,11}}; 
a为二维数组名, 此数组有3行4列, 共12个元素。但也可这样来理解, 数组a由三个元素组成: a[0], a[1], a[2]。而它匀中每个元素又是一个一维数组, 且都含有4个元素 (相当于4列), 例如, a[0]所代表的一维数组所包含的 4 个元素为 a[0][0], a[0][1], a[0][2], a[0][3]。如图5.所示: 
        ┏━━━━┓    ┏━┳━┳━┳━┓ 
a─→ ┃ a[0] ┃─→┃0 ┃1 ┃2 ┃3 ┃ 
        ┣━━━━┫    ┣━╋━╋━╋━┫ 
        ┃ a[1] ┃─→┃4 ┃5 ┃6 ┃7 ┃ 
        ┣━━━━┫    ┣━╋━╋━╋━┫ 
        ┃ a[2] ┃─→┃8 ┃9 ┃10┃11┃ 
        ┗━━━━┛    ┗━┻━┻━┻━┛ 
                    图5. 
    但从二维数组的角度来看, a代表二维数组的首地址, 当然也可看成是二维数组第0行的首地址。a+1就代表第1行的首地址, a+2就代表第2行的首地址。 如果此二维数组的首地址为1000, 由于第0行有4个整型元素, 所以a+1为1008, a+2 也就为1016。如图6.所示 
                            a[3][4] 
                   a    ┏━┳━┳━┳━┓ 
              (1000)─→┃0 ┃1 ┃2 ┃3 ┃ 
                   a+1 ┣━╋━╋━╋━┫ 
              (1008)─→┃4 ┃5 ┃6 ┃7 ┃ 
                   a+2 ┣━╋━╋━╋━┫ 
              (1016)─→┃8 ┃9 ┃10┃11┃ 
                        ┗━┻━┻━┻━┛ 
                              图6. 
    既然我们把a[0], a[1], a[2]看成是一维数组名, 可以认为它们分别代表它们所对应的数组的首地址, 也就是讲, a[0]代表第 0 行中第 0 列元素的地址, 即&a[0][0], a[1]是第1行中第0列元素的地址, 即&a[1][0], 根据地址运算规则, a[0]+1即代表第0行第1列元素的地址, 即&a[0][1], 一般而言, a[i]+j即代表第 i行第j列元素的地址, 即&a[i][j]。 
    另外, 在二维数组中, 我们还可用指针的形式来表示各元素的地址。如前所述, a[0]与*(a+0)等价, a[1]与*(a+1)等价, 因此a[i]+j就与*(a+i)+j等价, 它表示数组元素a[i][j]的地址。 
    因此, 二维数组元素a[i][j]可表示成*(a[i]+j)或*(*(a+i)+j), 它们都与a[i][j]等价, 或者还可写成(*(a+i))[j]。 
    另外, 要补充说明一下, 如果你编写一个程序输出打印a和*a, 你可发现它们的值是相同的, 这是为什么呢? 我们可这样来理解: 首先, 为了说明问题, 我们把二维数组人为地看成由三个数组元素a[0], a[1], a[2]组成, 将a[0], a[1], a[2]看成是数组名它们又分别是由4个元素组成的一维数组。因此, a表示数组第 0行的地址, 而*a即为a[0], 它是数组名, 当然还是地址, 它就是数组第0 行第0 
列元素的地址。 
    二. 指向一个由n个元素所组成的数组指针 
    在Turbo C中, 可定义如下的指针变量: 
      int (*p)[3]; 
    指针p为指向一个由3个元素所组成的整型数组指针。在定义中, 圆括号是不能少的, 否则它是指针数组, 这将在后面介绍。这种数组的指针不同于前面介绍的整型指针, 当整型指针指向一个整型数组的元素时, 进行指针(地址)加1运算, 表示指向数组的下一个元素, 此时地址值增加了2(因为放大因子为2), 而如上所定义的指向一个由3个元素组成的数组指针, 进行地址加1运算时, 其地址值增加了6(放大因子为2x3=6), 这种数组指针在Turbo C中用得较少, 但在处理二维数组时, 还是很方便的。例如: 
          int a[3][4], (*p)[4]; 
          p=a; 
    开始时p指向二维数组第0行, 当进行p+1运算时, 根据地址运算规则, 此时放大因子为4x2=8, 所以此时正好指向二维数组的第1行。和二维数组元素地址计算的规则一样, *p+1指向a[0][1], *(p+i)+j则指向数组元素a[i][j]。 
     例1 
     int a[3] [4]={ 
     {1,3,5,7}, 
     {9,11,13,15}, 
     {17,19,21,23} 
    }; 
    main() 
    { 
         int i,(*b)[4]; 
           b=a+1;                  /* b指向二维数组的第1行, 此时*b[0]或 
                                     **b是a[1][0] */ 
         for(i=1;i<=4;b=b[0]+2,i++)/* 修改b的指向, 每次增加2 */ 
           printf("%d\t",*b[0]); 
         printf("\n"); 
         for (i=0; i<2; i++) { 
           b=a+i;                  /* 修改b的指向, 每次跳过二维数组的 
                                      一行 */ 
           printf("%d\t",*(b[i]+1)); 
        } 
         printf ("\n"); 
     } 
    程序运行结果如下: 
     9    13   17   21 
     3    11   19









5.3.2 指针的数组
为什么要引入指针的数组？可以描述一类复杂的数据结构，更方便灵活。

在STL中，可以用vector的vector，vector的list ，list的vector之类的复合结构。

可以通过循环的方式，来调用多个指针指向的内容，也许是数据，也许是函数

int *p[2]; 首先声明了一个数组，数组的元素是int型的指针。
因为运算符的优先级, 因为[]的优先级比*高。所以第一种写法，p先和[]结合，所以是一个数组，后与*结合，是指针。
指针数组如下处理就会很清楚：
    typedef int* intPtr;
    intPtr p[2]; 
    一目了然，所以为了避免迷惑，做适当的typedef也是很有必要的。
上述定义等价于：float * (pf[3]);


比如 int * a[10];它里边放了１０个int * 型变量，由于它是一个数组，已经在栈区分配了１０个(int * )的空间，也就是３２位机上是４０个byte,每个空间都可以存放一个int型变量的地址，这个时候你可以为这个数组的每一个元素初始化，在，或者单独做个循环去初始化它。 
例子： 
int * a[2]={ new int(3),new int(4) };     //在栈区里声明一个int * 数组，它的每一个元素都在堆区里申请了一个无名变量，并初始化他们为３和４，注意此种声明方式具有缺陷，VC下会报错 
例如　： 
int * a[2]={new int[3],new int[3]}; 
delete a[0]; 
delet a[10]; 
但是我不建议达内的学生这么写，可能会造成歧义，不是好的风格，并且在VC中会报错，应该写成如下　： 
int * a[2]； 
a[0]= new int[3]; 
a[1]=new int[3]; 
delete a[0]; 
delet a[10]; 
这样申请内存的风格感觉比较符合大家的习惯；由于是数组，所以就不可以delete a;编译会出警告.delete  a[1]; 
注意这里 是一个数组，不能delete [] ;


二维指针数组
int *(*c)[3]=new int *[3][2]； 
如果你对上边的介绍的个种指针类型很熟悉的话，你一眼就能看出来c是个二级指针,只不过指向了一个二维int * 型的数组而已，也就是二维指针数组。 
例子　： 
 int *(*b)[10]=new int*[2][10];// 
b[0][0]=new int[100]; 
b[0][1]=new int[100]; 
*b[0][0]=1; 
cout <<*b[0][0]<<endl;    //打印结果为１ 
delete [] b[0][0]; 
delete [] b[0][1]; 
delete [] b; 
cout<<*b[0][0]<<endl;    //打印随机数 
　这里只为大家还是要注意内存泄露的问题，在这里就不再多说了。 
如果看了上边的文章，大家估计就会很熟悉，这个b是一个二维指针，它指向了一个指针数组


指针数组，怎么理解这个词呢，和前面我教大家理解指针常量和常量指针一样。指针数组首先应该是一个数组，即指针组成的数组，那么很容易理解，这个数组里面的元素都是指针类型的，比如我们定义一个字符数组　char *pn[]={"Fred","Barney","Wilma","Betty"};　其实指针数组就像一个二维数组，不过它比二维数组有更多的优势，就像一级指针和一维数组的区别一样，指针有更大的灵活性。指针数组首先建立一个一维数组空间，这块空间在内存中是连续的，这个一维数组中的每一个元素实际上都是一个指针（这是关键），这个指针指向内存的某个未知的空白区域，我们进行　cout<<pn[i]<<endl;　就可以把其中的四个字符串输出，比如我们定义“Fred”的时候，其实就是把“Fred”这个字符串放到内存中的一块空白区域中，然后把这个空间的首地址给指针数组的第一个数组元素，所以我们进行输出第一个数组元素的操作时（cout<<pn[0]<<endl;）它便可以通过这个pn[0]中的内容里的地址格式找到那块指向的地址空间，然后把它按字符串的形式输出（为什么会输出字符串，具体实现请看昨天的博客随笔《字符指针的特别之处》）。

　　下面我们看一段程序：

#include<iostream.h>
void print(char *[],int);
void main()
{
    char *pn[]={"Fred","Barney","Wilma","Betty"};
    int num=sizeof(pn)/sizeof(char *);
    print(pn,num);
}
void print(char *arr[],int len)
{
    for(int i=0;i<len;i++)    //输出各字符串
        cout<<(int)arr[i]<<"  "    //十进制输出字符串地址
            <<arr[i]<<endl;    //输出字符串
}

　　关于输出字符串地址为什么要用(int)arr[i]也请先看昨天的博客随笔《字符指针的特别之处》。下面我说说，为什么用　int num=sizeof(pn)/sizeof(char *);　可以得到字符串的数目，这里关系到指针数组的实质，好多人都弄不懂就是因为还没有理解透指针数组。
　　sizeof(pn)是求这个数组的长度，而不是它里面所包含的字符串的总长度，因为前面我们说过了，指针数组，首先是一个数组，只不过它里面的元素是指针，每种类型的指针的长度都是固定的（其实任何指针类型都是4个字节的长度），我们用这个数组中的每个指针元素的长度乘以数组元素的个数，即可以得到这个指针数组的长度，那么反过来我们就可以如果例子中一样求出它的指针元素个数，而每个指针都是指向一个字符串的，所以我们就可以得到一共有多少条字符串，一点也不复杂。


5.3.3 指针的指针





实践中一般很少超过二级指针，级数越多，可读性越差，越难理解，越容易产生混乱和出错。
指针   is   an   object   that   stores   the   address   of   another   object. 
example: 

int     i;       //   'i '   is   an   object. 
int*   p; 

p   =   &i; 


because   指针   is   also   an   object,   it   can   be   pointed   by   a   pointer. 
this   kind   of   pointer   is   called   指针的指针. 

example: 
int   i; 
int*   p; 
int**   pp; 

pp   =   &p; 

after   understanding   all   this,   the   usage   of   指针的指针   should   be   obvious. 
for   example,   you   can   use   指针的指针   to   get   a   2-D   array. 

void   func(   char**   s   )   {   strcpy(   s[0],   "fjkdjf "   ); 
strcpy(   s[1],   "fjkdjfkdjkfa "   ); 
} 

... 

char   str[3][100]   =   {   "11111 ",   "2222 ",   "3333 "   }; 
func(   str   );



指针的指针的用途？
利用指针的指针可以实现对二维数组的操作。

那么当操作二维树组时，对每一个数，用指针来操作时，就不能用普通指针了，因为它指向的只能是一种类型的，如int，char。 
需要指向a的首地址，此时就用到指向指针的指针了，


指针的指针 （用于访问指针的数组（保存指针的数组），数组的每个元素都是指针 ，比如说字符串） 举例

int ** cc=new (int*)[10]; 声明一个１０个元素的数组，数组每个元素都是一个int *指针，每个元素还可以单独申请空间，因为cc的类型是int*型的指针，所以你要在堆里申请的话就要用int *来申请； 
看下边的例子  (ｖｃ & GNU编译器都已经通过)； 
       int ** a= new int * [2];　　　　　//申请两个int * 型的空间 
       a[1]=new int[3];　　　　　　　　//为a的第二个元素又申请了３个int 型空间,a[1]指向了此空间首地址处 
       a[0]=new int[4];　　　　　　　　////为a的第一个元素又申请了４个int 型空间，a[0] 指向了此空间的首地址处 
       int * b; 
       a[0][0]=0; 
       a[0][1]=1; 
       b=a[0]; 
  delete [] a[0]　　　　　　　//一定要先释放a[0]，a[1]的空间，否则会造成内存泄露.; 
       delete [] a[1]; 
  delete [] a; 
       b++; 
       cout<<*b<<endl;       //随机数 
注意　：因为a 是在堆里申请的无名变量数组，所以在delete 的时候要用delete [] 来释放内存，但是a的每一个元素又单独申请了空间，所以在delete [] a之前要先delete [] 掉 a[0],a[1],否则又会造成内存泄露.


int **d[2];表示一个拥有两个元素数组，每一个元素都是int ** 型，这个指向指针的指针：） 
　　　d不管怎样变终究也是个数组，呵呵， 
　　　如果你读懂了上边的，那下边的声明就很简单了： 
　　　d[0]=new int *[10]; 
　　　d[1]=new int * [10]; 
delete [] d[0]; 
delete [] d[1]; 
具体的就不再多说了 ：）

二级指针的指针 
看下例 : 
int (**p)[2]=new (int(*)[3])[2]; 
       p[0]=new int[2][2]; 
       p[1]=new int[2][2]; 
       p[2]=new int[2][2]; 
       delete [] p[0]; 
       delete [] p[1]; 
       delete [] p[2]; 
       delete [] p; 
注意此地方的指针类型为int (*),碰到这种问题就把外边的[2]先去掉，然后回头先把int ** p＝new int(*)[n]申请出来，然后再把外边的［２］附加上去； 
p代表了一个指向二级指针的指针，在它申请空间的时候要注意指针的类型，那就是int (*)代表二级指针，而int (**)顾名思义就是代表指向二级指针的指针了。既然是指针要在堆里申请空间，那首先要定义它的范围：（int(*)[n]）[2]，n 个这样的二级指针，其中的每一个二级指针的最低维是２个元素.（因为要确定一个二级指针的话，它的最低维数是必须指定的，上边已经提到）。然后我们又分别为p[0],p[1],p[2]…在堆里分配了空间，尤其要注意的是：在释放内存的时候一定要为p[0],p[1],p[2],单独delete[] ,否则又会造成内存泄露，在delete[]p 的时候一定先delete p[0]; delete p[1]，然后再把给p申请的空间释放掉 delete [] p ……这样会防止内存泄露。


如果函数的参数是一个指针，不要指望用该指针去申请动态内存。示例7-4-1中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？ 

 void GetMemory(char *p, int num)//zbf:感觉非常隐蔽，设计错误 
 {      p = (char *)malloc(sizeof(char) * num);  
　　} 
void Test(void)  
{  
    char *str = NULL; 
  GetMemory(str, 100);    // str 仍然为 NULL  
    strcpy(str, "hello");   // 
运行错误 
　　示例7-4-1 试图用指针参数申请动态内存 
　　  
　　毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。（注意其原理解释） 
　　  
　　如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例7-4-2。
　　 void GetMemory2(char **p, int num)
{  
　　    *p = (char *)malloc(sizeof(char) * num);  
　　}
void Test2(void) 
{ 
    char *str = NULL; 
GetMemory2(&str, 100);  // 
注意参数是 &str，而不是str 
     strcpy(str, "hello");   
    cout<< str << endl;  
    free(str);  
 } 
　　
　　示例7-4-2用指向指针的指针申请动态内存  
 由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例7-4-3。
 char *GetMemory3(int num) 
{ 
    char *p = (char *)malloc(sizeof(char) * num); 
return p; 
}
　　示例7-4-3 用函数返回值来传递动态内存 
　　用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，因为该内存在函数结束时自动消亡，见示例7-4-4。



　　c++中指针,指针的引用,指针的指针的区别 
　　看例子和结果:
　　 #include "stdafx.h"
　　 #include <iostream>
　　 using namespace std;
　　 void FreePtr1(int* ptr1)
　　  {
　　     delete ptr1; 
　　     ptr1 = NULL;
　　 }
　　 
　　 void FreePtr2(int*& ptr2)
　　  {
　　     delete ptr2; 
　　     ptr2 = NULL;
　　 } 
　　 void FreePtr3(int **ptr3)
　　  {
　　     delete *ptr3;
　　     *ptr3 = NULL;
　　 }
　　 
　　 void main()
　　  {
　　     cout<<"---------------------------------------"<<endl;
　　     int *p1 = new int;
　　     *p1 = 1;
　　     cout<<"*p1="<<*p1<<endl;
　　     FreePtr1(p1);
　　     cout<<"after call freePtr1"<<endl;
　　     if(p1 != NULL)
　　      {
　　         cout<<"p1 is not null"<<endl;
　　         cout<<"*p1="<<(*p1)<<endl;
　　     }
　　     cout<<"---------------------------------------"<<endl;
　　     int *p2 = new int;
　　     *p2 = 2;
　　     cout<<"*p2="<<*p2<<endl;
　　     FreePtr2(p2);
　　     cout<<"after call freePtr2"<<endl;
　　     if(p2 != NULL)
　　      {       
　　         cout<<"*p2="<<*p2<<endl;
　　     }
　　     else
　　      {
　　         cout<<"the p2 is null"<<endl;
　　     }
　　     cout<<"---------------------------------------"<<endl;
　　     int *p3 ;
　　     p3 = new int(3);
　　     cout<<"*p3="<<*p3<<endl;
　　     FreePtr3(&p3);
　　     cout<<"after call freePtr3"<<endl;
　　     if(p3 != NULL)
　　      {       
　　         cout<<"*p3="<<*p3<<endl;
　　     }
　　     else
　　      {
　　         cout<<"the p3 is null"<<endl;
　　     }
　　     cout<<"---------------------------------------"<<endl;
　　     system("pause");
　　 
　　 }
　　
　　结果:
　　 
　　
　　
　　comments:
　　
　　对p1指针:
　　cout<<"---------------------------------------"<<endl;
　　 int *p1 = new int;
　　 *p1 = 1;
　　 cout<<"*p1="<<*p1<<endl;
　　 
　　// FreePtr1(p1);
　　void FreePtr1(int* ptr1)
　　{
　　 
　　 delete ptr1; 
　　 
　　 ptr1 = NULL;
　　 
　　}
　　 
　　 cout<<"after call freePtr1"<<endl;
　　 if(p1 != NULL)
　　 {
　　  cout<<"p1 is not null"<<endl;
　　  cout<<"*p1="<<(*p1)<<endl;
　　 }
　　 cout<<"---------------------------------------"<<endl;
　　
　　而p2为:
　　调用前:
　　 
　　调用后:
　　 
　　
　　
注意:函数的参数进行值拷贝,即使传的是指针,也的对指针(即指针里存的地址)的拷贝, 可不是指针里地址所指的值的拷贝啊!





5.3.4 复杂的指针表达式

各类指针

++*ptr等价于 ++(*ptr);
*ptr++ 等价于  *（ptr++）



自定义类型名来定义变量，用typedef  来简化指针类型的声明
如  typedef int * IntPtr;
typedef  int ** IntPtrPtr;
typedef  IntPtrPtr*  IntPtrPtrPtr;
typedef  char* CharPtr;

   特别地，对于特别复杂的指针。  实际当中，需要声明一个复杂指针时，如果把整个声明写成上面所示的形式，对程序可读性是一大损害。应该用typedef来对声明逐层分解，增强可读性，例如对于声明： 

int   (*(*func)(int   *p))[5]; 

可以这样分解： 

typedef     int   (*PARA)[5]; 
typedef   PARA   (*func)(int   *); 

这样就容易看得多了。

指针声明的阅读和理解
想正确使用指针；必须正确理解指针；指针的声明一句话讲完了；从变量名开始；看优先级；然后读指针含义
int (*(*f)(int,int(*)(int,float)))(int);
从f开始
1；*f//f是一个指针
2；(*f)()//f是一个函数指针
3；(*f)(int,int(*)(int,float)))//这个函数指针有2个参数int 和int(*)（int,float）;后面一个依然是函数指针；
4；函数f的返回值是什么；(*(*f)(int,int(*)(int,float)))//是指针；
5；这个指针指向什么(*(*f)(int,int(*)(int,float)))(int)//一个参数为int的函数；
6；这个返回的函数指针的返回值是什么int；
所以整体是说；我声明了一个指向2有个参数，返回值是函数指针的函数指针；而2个参数是int和执行函数的指针；


知道怎么读指针了；我们再来看看多维数组
int a[3][4];
这个C语言到底表达了什么意思？有人说3×4的数组；其实这个是不准确的；应该是3个向量；每个向量有4个int元素的数组；
现在我们看看这样一段代码
  int a[3][4];
  int **p;
  p = a;
//这个代码是有警告的；说指针类型不匹配；
那么我们看看这样的情况
  int a[3][4];
  int (*p)[4];
  p = a;
//这样的代码是没有警告的；因为类型匹配了；所以我们可以看出；p实际是指向了一个4个元素的数组；所以多维数组其实是一维数组的向量；


指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。   要搞清一个指针需要搞清指针的四方面的内容：指针的类型，指针所指向的   类型，指针的值或者叫指针所指向的内存区，还有指针本身所占据的内存区。让我们分别说明。   
　　先声明几个指针放着做例子：   
　　例一：   
　　(1)int*ptr;   
　　(2)char*ptr;   
　　(3)int**ptr;   
　　(4)int(*ptr)[3];   
　　(5)int*(*ptr)[4];   
　　 
　　指针的类型 
　　从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。让我们看看例一中各个指针的类型：   
　　(1)int*ptr;//指针的类型是int*   
　　(2)char*ptr;//指针的类型是char*   
　　(3)int**ptr;//指针的类型是int**   
　　(4)int(*ptr)[3];//指针的类型是int(*)[3]   
　　(5)int*(*ptr)[4];//指针的类型是int*(*)[4]   
　　怎么样？找出指针的类型的方法是不是很简单？   
　　指针所指向的类型 
　　当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。   
　　从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：   
　　(1)int*ptr;//指针所指向的类型是int   
　　(2)char*ptr;//指针所指向的的类型是char   
　　(3)int**ptr;//指针所指向的的类型是int*   
　　(4)int(*ptr)[3];//指针所指向的的类型是int()[3]   
　　(5)int*(*ptr)[4];//指针所指向的的类型是int*()[4]   
　　在指针的算术运算中，指针所指向的类型有很大的作用。   
　　指针的类型(即指针本身的类型)和指针所指向的类型是两个概念。当你对C越来越熟悉时，你会发现，把与指针搅和在一起的 "类型 "这个概念分成 "指针的类型 "和 "指针所指向的类型 "两个概念，是精通指针的关键点之一。我看了不少书，发现有些写得差的书中，就把指针的这两个概念搅在一起了，所以看起书来前后矛盾，越看越糊涂。 



右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。 

                笔者要对这个法则进行一个小小的修正，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。 

                现在通过一些例子来讨论右左法则的应用，先从最简单的开始，逐步加深： 

int   (*func)(int   *p); 

首先找到那个未定义的标识符，就是func，它的外面有一对圆括号，而且左边是一个*号，这说明func是一个指针，然后跳出这个圆括号，先看右边，也是一个圆括号，这说明(*func)是一个函数，而func是一个指向这类函数的指针，就是一个函数指针，这类函数具有int*类型的形参，返回值类型是int。 

int   (*func)(int   *p,   int   (*f)(int*)); 

func被一对括号包含，且左边有一个*号，说明func是一个指针，跳出括号，右边也有个括号，那么func是一个指向函数的指针，这类函数具有int   *和int   (*)(int*)这样的形参，返回值为int类型。再来看一看func的形参int   (*f)(int*)，类似前面的解释，f也是一个函数指针，指向的函数具有int*类型的形参，返回值为int。 

int   (*func[5])(int   *p); 

func右边是一个[]运算符，说明func是一个具有5个元素的数组，func的左边有一个*，说明func的元素是指针，要注意这里的*不是修饰func的，而是修饰func[5]的，原因是[]运算符优先级比*高，func先跟[]结合，因此*修饰的是func[5]。跳出这个括号，看右边，也是一对圆括号，说明func数组的元素是函数类型的指针，它所指向的函数具有int*类型的形参，返回值类型为int。 


int   (*(*func)[5])(int   *p); 

func被一个圆括号包含，左边又有一个*，那么func是一个指针，跳出括号，右边是一个[]运算符号，说明func是一个指向数组的指针，现在往左看，左边有一个*号，说明这个数组的元素是指针，再跳出括号，右边又有一个括号，说明这个数组的元素是指向函数的指针。总结一下，就是：func是一个指向数组的指针，这个数组的元素是函数指针，这些指针指向具有int*形参，返回值为int类型的函数。 

int   (*(*func)(int   *p))[5]; 

func是一个函数指针，这类函数具有int*类型的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组。 

要注意有些复杂指针声明是非法的，例如： 

int   func(void)   [5]; 

func是一个返回值为具有5个int元素的数组的函数。但C语言的函数返回值不能为数组，这是因为如果允许函数返回值为数组，那么接收这个数组的内容的东西，也必须是一个数组，但C语言的数组名是一个右值，它不能作为左值来接收另一个数组，因此函数返回值不能为数组。 

int   func[5](void); 

func是一个具有5个元素的数组，这个数组的元素都是函数。这也是非法的，因为数组的元素除了类型必须一样外，每个元素所占用的内存空间也必须相同，显然函数是无法达到这个要求的，即使函数的类型一样，但函数所占用的空间通常是不相同的。 

作为练习，下面列几个复杂指针声明给读者自己来解析，答案放在第十章里。 

int   (*(*func)[5][6])[7][8]; 

int   (*(*(*func)(int   *))[5])(int   *); 

int   (*(*func[7][8][9])(int*))[5];


第八章练习的答案，同时给出用typedef的分解方法：

int (*(*func)[5][6])[7][8];
func是一个指向数组的指针，这类数组的元素是一个具有5X6个int元素的二维数组，而这个二维数组的元素又是一个二维数组。
typedef int (*PARA)[7][8];
typedef PARA (*func)[5][6];

int (*(*(*func)(int *))[5])(int *);
func是一个函数指针，这类函数的返回值是一个指向数组的指针，所指向数组的元素也是函数指针，指向的函数具有int*形参，返回值为int。
typedef int (*PARA1)(int*);
typedef PARA1 (*PARA2)[5];
typedef PARA2 (*func)(int*);
int (*(*func[7][8][9])(int*))[5];
func是一个数组，这个数组的元素是函数指针，这类函数具有int*的形参，返回值是指向数组的指针，所指向的数组的元素是具有5个int元素的数组。
typedef int (*PARA1)[5];
typedef PARA1 (*PARA2)(int*);
typedef PARA2 func[7][8][9];



5.4 指针与内存管理
指针的主要用途在于手动内存管理，这也是其强大并且几乎是不可替代之处。虽然现代的很多语言都陆续添加了自动垃圾收集等技术，让系统代替人来管理内存。
　　但是即使是在C++ 11最新标准，C++仍然选择了保留指针，让程序员来手动管理内存。但是，C++ 11标准中也添加了智能指针，增加了些理解的复杂性，牺牲了一些效率，但是提高了指针的安全性。可以在了解的基础上进一步学习。

5.4.1 堆和栈的基本概念
堆栈是一种简单的数据结构，是一种只允许在其一端进行插入或删除的线性表。允许插入或删除操作的一端称为栈顶，另一端称为栈底，对堆栈的插入和删除操作被称为入栈和出栈。有一组CPU指令可以实现对进程的内存实现堆栈访问。其中，POP指令实现出栈操作，PUSH指令实现入栈操作。CPU的ESP寄存器存放当前线程的栈顶指针，EBP寄存器中保存当前线程的栈底指针。CPU的EIP寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行。 



     从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程
序的.而这种不同又主要是由于堆和栈的特点决定的:  

     在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形
式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好
像工厂中的传送带(conveyor  belt)一样,Stack  Pointer会自动指引你到放东西的位置,
你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁
.这样的模式速度最快,当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即
将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在
程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个"大小多少"是在编译时确
定的,不是在运行时.  

     堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内
存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编
译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时
间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是
必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中
，要求创建一个对象时，只需用new命令编制相关的代码即可。执行这些代码时，会在堆里
自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储
空间时会花掉更长的时间！这也正是导致效率低的原因,





堆和栈的区别可以用如下的比喻来看出：
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了
就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但
是自由度小。
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自
由度大

食堂 的模式：  固定座位和吃完就走

5.4.2 内存中堆和栈的区别
c＋＋内存格局通常分为：
全局数据区
代码区
栈区
堆区


栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。  
堆上分配的内存可以有我们自己决定，使用非常灵活。  

一个由c/C++编译的程序占用的内存分为以下几个部分
1、栈区（stack）—   由编译器自动分配释放 ，存放函数的参数值，局部变量的值等
。其操作方式类似于数据结构中的栈。
2、堆区（heap） —   一般由程序员分配释放， 若程序员不释放，程序结束时可能由
OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化
的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻
的另一块区域。 - 程序结束后有系统释放
4、文字常量区  —常量字符串就是放在这里的。 程序结束后由系统释放
5、程序代码区—存放函数体的二进制代码。
二、例子程序
这是一个前辈写的，非常详细
//main.cpp
int a = 0; 全局初始化区
char *p1; 全局未初始化区
main()
{
int b; 栈
char s[] = "abc"; 栈
char *p2; 栈
char *p3 = "123456"; 123456\0在常量区，p3在栈上。
static int c =0； 全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20);
分配得来得10和20字节的区域就在堆区。
strcpy(p1, "123456"); 123456\0放在常量区，编译器可能会将它与p3所指向的"12345
6"优化成一个地方。
}

内存分配方式有三种：
（1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的
整个运行期间都存在。例如全局变量，static 变量。
（2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函
数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集
中，效率很高，但是分配的内存容量有限。
（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多
少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期
由我们决定，使用非常灵活，但问题也最多。





5.4.2.1 申请方式
stack:由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间
heap:需要程序员自己申请，并指明大小，在c中malloc函数
如p1 = (char *)malloc(10);
在C++中用new运算符
如p2 = (char *)malloc(10);
但是注意p1、p2本身是在栈中的。




5.4.2.2 申请后系统的响应
栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈
溢出。
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时
，
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链
表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间
中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存
空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多
余的那部分重新放入空闲链表中。

在申请空间后，栈的分配要比堆的快。对于堆，先遍历存放空闲存储地址的链表、修改链表、再进行分配；对于栈，只要剩下的可用空间足够，就可分配到，如果不够，那么就会报告栈溢出。

5.4.2.3 申请大小的限制
栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的
意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（
也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间
时，将提示overflow。因此，能从栈获得的空间较小。
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存
储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的
大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较
大。
堆是由低地址向高地址扩展，栈是由高地址向低地址扩展。堆是不连续的空间，栈是连续的空间。
5.4.2.4 申请效率的比较：
栈由系统自动分配，速度较快。但程序员是无法控制的。
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈
是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵
活。
5.4.2.5 堆和栈中的存储内容
栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条
可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左
入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的
地址，也就是主函数中的下一条指令，程序由该点继续运行。
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。
5.4.2.6 存取效率的比较
char s1[] = "aaaaaaaaaaaaaaa";
char *s2 = "bbbbbbbbbbbbbbbbb";
aaaaaaaaaaa是在运行时刻赋值的；
而bbbbbbbbbbb是在编译时就确定的；
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。
比如：
#include
void main()
{
char a = 1;
char c[] = "1234567890";
char *p ="1234567890";
a = c[1];
a = p[1];
return;
}
对应的汇编代码
10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读
到edx中，在根据edx读取字符，显然慢了。

5.4.2.7 生命周期的比较
栈的生命期最短，到函数调用结束时；静态存储区的生命期最长，到程序结束时；堆中的生命期是到被我们手动释放时（如果整个过程中都不手动释放，那就到程序结束时）。            


5.4.3 C++与堆内存分配

8 memcpy
除非没有类似的库函数，否则不要重新写一个。要知道，绝大多数编译器会对这些库函数作特殊优化。这是手工编码无法做到的。	
	
	
	14 关于new/delete 与malloc/free
你用了类似class的关键字后，就注定不兼容于c了。因此，用了c++的东西，就不要去用mallco/free，除非特殊情况。
同理，不使用c++的东西，也决不要去用new /delete.
否则，你的跨语言或跨平台的想法就打水漂了。还容易出错。


栈是随函数被调用时分配的空间
    栈上分配的空间是临时的，在函数退出后将被系统释放，
不会造成内存泄露，不得用delete或free操作，因为栈的空间小
所以在栈上不能获得大量的内存块，一般最大也就不到10M
    堆是在整个进程的未分配空间中分配的内存，由malloc或new
分配，一般必须由free或delete释放。堆上可以分配大量的内存，只要
你的机器吃得消。
   一般来说，由new和malloc分配的内存都在堆上，全局变量也在
堆上（但是不是new，malloc出来的也会自动清理）。函数内部的其
他变量和常量都在栈上。
关于malloc/free 和new /delete
malloc/free 是C/C+的内存分配符，new /delete是C++的内存分配符。
注意：malloc/free是库函数，new/delete是运算符
malloc/free不能执行构造函数与析构函数，而new/delete可以
new/delete不能在C上运行，所以malloc/free不能被淘汰
两者都必须要成对使用
C++中可以使用_set_new_hander函数来定义内存分配异常的处理

　1、 指针创建时必须被初始化
2、 指针在free 或delete后必须置为NULL




十、内存分配的注意事项
用new或malloc分配内存时，必须要对此指针赋初值。
用delete 或free释放内存后，必须要将指针指向NULL
不能修改指向常量的指针数据

十一、内容复制与比较 
//数组……
char a[]=”Hello Word!”;
char b[10];
strcpy(b,a);
if (strcmp(a,b)==0)
{}
//指针……
char a[]=”Hello Word!”;
char *p;
p=new char[strlen(a)+1];
strcpy(p,a);
if (strcmp(p,a)==0)
{}




5.5 指针的功与过


1. 为什么指针比较危险？
   只要我们掌握对象的内存地址（它的指针），那么就可以在任何地方队其指向的内存单元进行操作，无论是读写还是调用其函数。这种灵活性正是指针危险（可能指向无效内存对象）
和不易掌握的主要原因。如果访问了非法或者无效的内存单元，就会导致运行时错误。（分别截图）
　　　指针理论上可以修改任意内存的值，可能会导致其它程序出错，或者系统崩溃（若无保护措施）

2. 应该怎样对待指针？
C/C++程序员们对于可以说是 又恨又爱，恨的是  爱的是。。
在长期的实践中，也总结出一些好的经验
如使用智能指针的技法
从语言方面来说，随着C++ 标准的不断变化，更是直接 加入了对智能指针的支持。

    指针是C语言规范里面一项核心内容，指针具有与生俱来的优势，利用指针可以写出许多短小精悍、效率极高的代码，它是C语言一把无可替代的利器，凭着这把利器，C语言与其它高级语言相比至少在效率方面高人一筹。但是，由于指针的原理与使用方式跟人们通常的思维习惯有较大的差别，造成了指针比C语言其它概念难理解得多，这使得对指针认识不足成为了一种在C程序员中普遍存在的现象，这种不足必然导致程序员在指针的使用过程中不断遭受挫折，挫折多了，指针俨然变成一道无法逾越的难关，恐惧感也就油然而生了。在恐惧感面前，某些程序员甚至产生了要避免使用指针的念头，这是非常不可取的。指针是如此犀利，正是它才使得C语言威猛无比，如果就这样把它放弃了，那么C语言就算是白学了。我们应当让指针成为你手中那把砍掉索伦手指上魔戒的举世无双的纳西尔圣剑，而不是成为你心中永远的魔戒。

指针操作最初是为了效率，省却转换，但使得代码难懂

C++ 为何不加入垃圾回收的原因解释： 贯穿的原则  效率第一，高水平的程序员开发基础的软件，需求变动不大，精雕细刻，  

  C++实谓各种语言中的软肋，功能强大，陷阱更强大。当然我认为一门语言用得不好完全是程序员的责任，不过因为C++涉及到的概念实在是太多，想用好实在也不是一件容易的事情。C++开发的时候总是会遇到各种各样的问题，其中最严重的无非是内存相关的。C语言由于结构简单，内存处理起来虽然不得力，但总的来说惯用法已经深入人心，因此也不会造成什么很难发现的错误。但是不能因此因噎废食。
3. 什么时候该用指针，什么时候该用引用
引用能做的事情指针都能做，为什么要“引用”？
指针既有指针的效率，又有变量使用的方便性和直观性
用适当的工具做恰如其分的工作   杀鸡焉用牛刀  
“引用体现了最小特权的原则”

刀可以砍树，裁纸 修指甲 （）   理发 （）谁敢这么用？艺高人胆大

只需要一份证明，在文件上盖章就可以了，不需要把公章交给他




受限的指针——引用的本质
    正是因为指针威力强大，但是操作不当的话，也很危险，因此，C++引入了“引用”的概念，力图在保留指针绝大部分的强大功能的同时，给指针添加若干限制，防止可能的越界等错误的产生。
  
。
5.1.3 引用的概念
  “引用”只是用户编程模型中的概念，在经过编译器的预处理后，就转换为某种受限的指针，可以从汇编代码底层来看这个问题。
   因为引用本质上市指针，因此，只要不是与其限制相冲突，指针能做的基本上引用都是可以的，比如说数组的引用，引用的数组，引用的引用这些概念是否都存在。
但是，也有着不适应的，如有指针的指针，但是下列不对：
	int & *p; //不能建立指向引用的指针；int *a; int * & p=a; //正确，指针变量的引用


即使是合法的，也会处理方法不同相同：



//定义如下数组
int my_ary[10] = {0};

//想在此函数中对其进行处理
void Func(int &ary[]);
Func(my_ary);//错误

void Func(int &ary[]，int aryLen);
Func(my_ary, 10);//错误



定义数组的引用时，必须指明数组的维数， int my_ary[10] 和 int my_ary[5]不是同一种类型。
//定义如下数组
int my_ary[10] = {0};

//想在此函数中对其进行处理
void Func((int &) ary[10])
{

};

void Func2((int &) ary[10],int aryLen)
{
	
};

main()
{
	Func(my_ary);//错误
	Func2(my_ary, 10);//错误
}



c++primer有讲 
引用必须被初始化 
而数组并不能被另一个数组初始化或被另一个数组赋值 
所以定义引用的数组非法
C++标准已经明确禁止。



5.1.1 右值引用




理论解释：

编译器的错误提示：




因此，我们在使用引用的时候，一方面要牢记其指针本质，一方面要理解其所受限制的原因，这样才能理解其与指针的相同点和不同点，而不用去死记硬背。

下面侧重从用户角度，来看两者使用上的不同。

5.1.2 引用与指针的不同
指针的间接是增加了一个关注目标的功能或者提供的服务接口层，和原有的直接访问的方式是串行的关系，引用的间接是增加了关注目标对象的使用场合或者环境的名称层，和原有的直接访问的方式是并行的关系。如图所示：



引用的自动跳转

为了进一步加深大家对指针和引用的区别，下面从编译的角度来阐述它们之间的区别：
程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值。符号表生成后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。
也就是说：引用就像能自动被编译器逆向引用的常量指针一样，当使用引用名时，编译器默认根据引用中存储的地址找到它所指向的目标变量进行处理，正因为编译器能够自动帮我们实现了跳转，按照这种默认规则找到目标变量，因此语法上也不用出现指针的*或者-> 指示符，给外界的感觉是引用是它所关联的变量对象的另外一个名称。
虽然引用在底层实现上基于指针，但是具有常量的特征。它的常量性体现在所指向的对象的不变。
从本质上来说，引用相当于指针的特化，也就是说：相当于实施了一定限制或者说约束的指针。因此也相应会带来了很多的变化，我们在后面还会从语法格式、地址概念期等多方面详细比较下指针和引用之间的不同之处。
C++增加“引用”机制，可以弥补指针的不足，许多原先用指针才能解决的问题，可以改用“引用”来解决。


 引用和指针使用原则：
1.在可以用引用的情况下，不要用指针；
2.引用不允许重新赋值.，当使用一个变量指向不同的对象时,必须用指针；
3.引用不允许为空，当存在对象为空时,必须使用指针。 

引用说明:
(1) double & rr=1; 等价与 double temp； temp＝double（1）； double & rr＝temp；
(2) int *a; int * & p=a; int b=8; p=&b; //正确，指针变量的引用
void & a=3; //不正确，没有变量或对象的类型是void
int & ri=NULL； //不正确，有空指针，无空引用
(3) int & ra=int; //不正确，不能用类型来初始化
int *p=new int; int & r=*p; //正确
(4) 引用不同于一般变量，下面类型声明是非法的：
int &b[3]; //不能建立引用数组
int & *p; //不能建立指向引用的指针
int &&r; //不能建立引用的引用
(5) 当使用&运算符取一个引用的地址时，其值为所引用变量的地址， 
 
一段代码：
 
#include <iostream>
using namespace std;
void freePtr1(int* p1)
{
   delete p1; 
   p1 = NULL;
}
void freePtr2(int*& p2)
{
   delete p2; 
   p2 = NULL;
}
 
void main()
{
   int *p1 = new int;
   *p1 = 1;
   freePtr1(p1);
   int *p2 = new int;
   *p2 = 2;
   freePtr2(p2);
   system("pause");
}
思考：在freePtr1和freePtr2 的比较中，你能发现它们的不同点吗？
 
二、对代码进行解释：
#include <iostream>
using namespace std;
void freePtr1(int* p1)
{
   //未释放内存前 ->  p1 Address : 0012FDDC  p1 value : 003429B8，在这里，p1它也是一个变量，既然是一个变量，那么它将会以值的传递，把外部变量p1传到栈内，在栈内产生一个地址：0012FDDC，当然，它的值不会变仍然是指向堆地址：003429B8 。
   delete p1; //系统回收p1值的地址003429B8处的内存。
p1 = NULL;//对p1赋以NULL值即：00000000，注意：p1本身的地址并没有变，变的是p1的值。
   //释放内存后 ->  p1 Address : 0012FDDC  p1 value : 00000000，出栈后，p1由于是一个临时对象，出栈后它会自动被视为无效。
}
void freePtr2(int*& p2)
{
   //未释放内存前 ->  p2 Address : 0012FEC8  p2 value : 003429B8，p2是一个指针的引用，即引用指向指针，记住引用的特点：对引用的对象直接操作。所以它的地址和值与栈外的main()函数中，p2的值是同一个。
   delete p2; //对p2所引用的指针进行释放内存，即：系统回收main()函数中 p2的值 003429B8 地址处的内存。
   p2 = NULL;//对main()函数中p2的指针赋以NULL值。 
   //释放内存后 ->  p2 Address : 0012FEC8  p2 value : 00000000，由于操作的对象都是main()函数中的p2,所以它将应用到原变量中。
}
 
void main()
{
   int *p1 = new int;
//释放内存前->  p1 Address : 0012FED4  p1 value : 003429B8
   freePtr1(p1);
   //释放内存后->  p1 Address : 0012FED4  p1 value : 003429B8
 
   int *p2 = new int;
   //释放内存前->  p2 Address : 0012FEC8  p2 value : 003429B8
   freePtr2(p2);
   //释放内存后->  p2 Address : 0012FEC8  p2 value : 00000000
   system("pause");
}
－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
指针引用的经典用法：

#include <iostream>
using namespace std;

void all1(int **p)
{
 int *pp = new int;
 *p = pp;
}
void all2(int*& p)
{
 int *pp = new int;
 p = pp;
}
void main()
{
 int *a1;
 all1(&a1);
 *a1 = 1;
 cout<<*a1<<endl;
 int *a2;
 all2(a2);
 *a2 = 2;
 cout<<*a2<<endl;
 
}



1. 语法格式不同
定义引用的表示方法与定义指针相似，只是用&代替了*。
例如： int a=3;
       int *p=&a;  //此处的&是求地址运算
       int &b=a;    //此处的&是用来标识“引用”
       *p=4;   //将a的值变为4
        b=5；  //将a的值变为5
　引用的操作与对变量直接操作完全一样，而 指针则需通过 *  和  -> （对结构体或者类对象）来操作。
2. 地址的概念不同
　虽然都是地址的概念，但是指针指向一块内存，它的内容是所指内存的地址，可以为空；而引用则是某块内存的别名，不能为空。
   并且引用不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。引用名本身是没有地址的，正因为如此，声明引用的引用、指向引用的指针或者引用的数组都是不合法的！对引用求地址，就是对目标变量求地址。
　　不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

Int &&rri=ra    //错误
Int   &*pri;     //错误
Int  &ar[3];      //错误

引用不可能带有常量性
Int  &const cri=a;   //错误
Cons int &rci=a;   //ok,编译器忽略了这些修饰词

没有空引用，也没有类型为void的引用

C  *p=0;
C  &rc=*p;     //把引用绑定到空指针上，结果未定义
Extern void  &rv;     //试图申明类型为void的引用，编译器会报错

   p是指针， &&p 不对，因为  &p已经不是变量了，不能对字面常量使用 & 来取地址 。因为字面常量保存在符号表中，它们没有地址概念！
3. 绑定对象方式不同

　　直观的含义来看，指针和引用的区别在于所存放的地址：指针是指向初始化时不确定的对象，而引用则是指向初始化时固定的对象。这样，则随之而来的规则和使用方法也产生了较大的差异。
　　引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
　　 ra=1; 等价于 a=1;

引用创建时必须初始化，引用到1个有效对象，指针则不用，可以再定义后面再重新赋值,指针务必进行初始化，要么赋予它一个有效的地址，要么NULL（注意，不是null）。引用只能在定义时被初始化一次，之后不可变；指针可变；引用“从一而终”，指针可以“见异思迁”；
引用一旦被初始化，它就不能改变为另一个对象的引用。（从一而终，矢志不渝） ，而引用是一个别名，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化，而且其引用的对象在其整个生命周期中是不能被改变的（自始至终只能依附于同一个变量）。
从概念上讲。指针从本质上讲就是存放变量地址的一个变量，在逻辑上是独立的，它可以被改变，包括其所指向的地址的改变和其指向的地址中所存放的数据的改变。指针任何时候都可以改变指向

例如下面语句是非法的：
Point &pt3；
pt3=pt1；

4. 支持的运算不同



（1） “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身的大小；
（2） 指针和引用的自增(++)运算意义不一样；
5. 函数传递机制不同
　　（部分内容要移到函数参数传递中详解！）
实际上，用指针还更容易让人明白传进去的是指针。而引用则不然。引用的引入，在c++中是为了解决运算符重载的问题。  (其它语言中有没有类似引用的机制？？？
　　
　　
　　在C++中，指针和引用经常用于函数的参数传递，然而，指针传递参数和引用传递参数是有本质上的不同的：
　　指针传递参数本质上是值传递的方式，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。（这里是在说实参指针本身的地址值不会变）
　　而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。
　　引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将影响不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量，那就得使用指向指针的指针，或者指针引用。
　　
6. 使用的时机不同
（1） 使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数等情况都推荐使用引用。

引用在C++最初是为了支持运算符重载的问题引入，同时它也也为函数参数的传人和传出的控制提供便利。
7. 编译器默认的一些处理不同
指向数组的引用保留了数组尺寸的信息，而指针则不保留
举例，一维数组，二维数组，  这个性质有时候在多维数组作为参数被传递给函数时有用


8. 类型安全不同
（1） 引用没有const，指针有const，const的指针不可变；（具体指没有int& const a这种形式，而const int& a是有的，  前者指引用本身即别名不可以改变，这是当然的，所以不需要这种形式，后者指引用所指的值不可以改变）

Const int& rInt =0  表示创建1个临时的int ,并初始化为0，再用它来初始化引用，而该来临时对象一直保留到rInt销毁时才销毁。 所以不要用字面常量来初始化引用（？）。相当于 
Int temp=0;
Int rInt&=temp;


（2） 引用是类型安全的，而指针不是 (引用比指针多了类型检查



5.6 思考与练习
12）懂什么是链表么？会链表的一些基本操作么？ 

（13）明白队列，双链表，循环链表，栈是怎么回事？会写这些类。


想起前两天有人发的面试题，其中有strcmp的实现，转这个过来，给大家看看。
题目：  
  已知strcpy函数的原型是：  
  char * strcpy(char * strDest,const char * strSrc);  
  1.不调用库函数，实现strcpy函数。  
  2.解释为什么要返回char *。  

  解说：  
  1.strcpy的实现代码  

  char * strcpy(char * strDest,const char * strSrc)

  {

  if ((strDest==NULL)||(strSrc==NULL)) //[1]

  throw "Invalid argument(s)"; //[2]

  char * strDestCopy=strDest; //[3]

  while ((*strDest++=*strSrc++)!='\0'); //[4]

  return strDestCopy;

  }


  错误的做法：  
  [1]  
  (A)不检查指针的有效性，说明答题者不注重代码的健壮性。  
  (B)检查指针的有效性时使用((!strDest)||(!strSrc))或(!(strDest&&strSrc))，说明答题者对C语言中类型的隐式转换没有深刻认识。在本例中char *转换为bool即是类型隐式转换，这种功能虽然灵活，但更多的是导致出错概率增大和维护成本升高。所以C++专门增加了bool、true、false三个关键字以提供更安全的条件表达式。  
  (C)检查指针的有效性时使用((strDest==0)||(strSrc==0))，说明答题者不知道使用常量的好处。直接使用字面常量（如本例中的0）会减少程序的可维护性。0虽然简单，但程序中可能出现很多处对指针的检查，万一出现笔误，编译器不能发现，生成的程序内含逻辑错误，很难排除。而使用NULL代替0，如果出现拼写错误，编译器就会检查出来。  
  [2]  
  (A)return new string("Invalid argument(s)");，说明答题者根本不知道返回值的用途，并且他对内存泄漏也没有警惕心。从函数中返回函数体内分配的内存是十分危险的做法，他把释放内存的义务抛给不知情的调用者，绝大多数情况下，调用者不会释放内存，这导致内存泄漏。  
  (B)return 0;，说明答题者没有掌握异常机制。调用者有可能忘记检查返回值，调用者还可能无法检查返回值（见后面的链式表达式）。妄想让返回值肩负返回正确值和异常值的双重功能，其结果往往是两种功能都失效。应该以抛出异常来代替返回值，这样可以减轻调用者的负担、使错误不会被忽略、增强程序的可维护性。  
  [3]  
  (A)忘记保存原始的strDest值，说明答题者逻辑思维不严密。  
  [4]  
  (A)循环写成while (*strDest++=*strSrc++);，同[1](B)。  
  (B)循环写成while (*strSrc!='\0') *strDest++=*strSrc++;，说明答题者对边界条件的检查不力。循环体结束后，strDest字符串的末尾没有正确地加上'\0'。  

  2.返回strDest的原始值使函数能够支持链式表达式，增加了函数的“附加值”。同样功能的函数，如果能合理地提高的可用性，自然就更加理想。  
  链式表达式的形式如：  
  int iLength=strlen(strcpy(strA,strB));  
  又如：  
  char * strA=strcpy(new char[10],strB);  
  返回strSrc的原始值是错误的。其一，源字符串肯定是已知的，返回它没有意义。其二，不能支持形如第二例的表达式。其三，为了保护源字符串，形参用const限定strSrc所指的内容，把const char *作为char *返回，类型不符，编译报错。



看了太多关于内存使用上出问题的代码,感觉很多人知道new,知道malloc,却不知道该如何管理,觉得有必要讲讲c/c++程序对内存占用类型的区别.
引用一个前辈注释的例子.请新手朋友仔细看看每一处,你是否都清楚?
//main.cpp
int a = 0; //a,全局变量,存储在全局初始化区
char *p1; //p1,全局变量指针,全局未初始化区(注意,p1没有new或者malloc,它是一个空指针,你乱用就是野指针,但是它是地址,本身也占32位的空间)
main()
{
int b; //main()函数的栈区
char s[] = "abc"; //main()函数的栈区
char *p2; // p2也是指针,main()函数的栈区  
char *p3 = "123456"; //123456\0在常量区，p3在main()函数的栈区
static int c =0； //全局（静态）初始化区
p1 = (char *)malloc(10);
p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区。但是p1在全局区,p2在main()函数的栈区,你懂了吗?
strcpy(p1, "123456"); // 123456\0放在常量区，编译器可能会将它与p3所指向
的"123456"优化成一个地方
}

上面的一小段代码,可以看出,一段代码占用内存,基本有一下几种:
1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。  
2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。  
3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后由系统释放。
4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放 。
5、程序代码区—存放函数体的二进制代码。  
关于内存缓冲池,碎片等,不讨论了,只要你看懂上面那段代码的注释,我的目的就达到了.
再次呼吁,请高手进来指点一下,提点你自己的经验.




第六章   函数与模块化
   ——分门别类
　　
　　在前面学习中，由于代码都比较简短，因此我们是直接将代码全部放在主函数内。但在实际开发过程中，这种情况很少见。因为随着代码规模越来越大，这种方法几乎不可用。这种情况好比将所有的东西都随便堆放在仓库里面。随着物品的增多，就显得杂乱无章，管理起来就会很困难。对于仓库管理，我们可以将物品分门别类放到箱子里，然后整齐有序地堆放在货架上。同样类似，对于代码，我们也引入某种类似箱子的包装来对代码进行分门别类，这个引入的包装就是C++中的“函数”。
　　“函数”这个词起源于数学，其英文名是function, 翻译过来的这个“函”字其实很有意思很准确。“函”本身有包含的意思，如函谷关等地名。
   在数学中，函数f(x)包含的是具有特定功能的一个表达式，需要参数作为初始值。编程语言包括C++中的函数这个概念都是沿用数学中的函数概念，因此，很多时候在理解C++中的函数这个概念的时候，可以类比于数学中的函数，如C++中的函数包含具有特定功能的一段代码，也需要参数。
　　可见，函数这个编程上一个极其重要的概念的产生，来源于抽象的模块化思想和程序开发的实际需求相结合，再借助于数学上函数的形式化描述。模块化是思想，函数是实现。
　　能构成模块的不仅仅有函数，还包含类、组件等多种形式，但是函数是模块化思想在C++中最常用也最基础的重要应用实例，模块化思想也是函数的思想精髓。因此，下面从函数模块化的角度来理解函数。
　　
6.1 模块化的要素
6.1.1 函数模块的层次
　　在设计时，我们通常采用自上而下的方法，来将所要解决的问题逐步细化分解，然后每个小问题用一个函数来解决，分而治之的方法。
　　例如：
　　在具体实现的时候，也可以采取这种方式，即先明确好函数的接口，然后在填写具体的内容。
　　自上而下 和自下而上
　　
　　从不同的角度出发，依据对功能的划分，模块化的形式也不一致。
　　
　　分解的目的是为了组合起来。
　　
　　我们再次用仓库管理来类比下，我们是根据仓库中各类货物的当前的和估计将来的数量，然后分别划定区域的大小。
　　
　　静态，动态 （仓库各货物的搭配？）
　　
　　这种模块化的类似于搭积木的构建程序的方式体现了结构化编程的思想。这种结构化设计的精髓思想是自顶向下、逐步求精的思维方式，以宏观到微观，以任务为中心。
　　举例
　　
　　代码的管理层次，一层层的。
　　
    我们


函数调用时程序的执行流程
（调试 F11  max函数 举例） 在调试的时候设置断点来查看
　　
　　
6.1.2 函数模块的角度
如编写一个个人文件管理的软件
按照管理过程可以划分功能： 读取文件，编辑文件，保存文件等；
按照文件类型可以分为 管理word文档，管理ppt文档，管理.cpp文件等。

6.1.3 函数模块的粒度
　　很大小函数，几个大函数
　　典型的C语言程序，main函数中间调用函数，再调用
　　模块化并不是越细越好。
　　同样，函数并不是越划分多越好。
　　
6.1.4 函数模块的接口
　　模块化总是伴随着接口的标准化。为了和系统交互，程序必须遵守系统的API这一标准，windows平台有windows的标准，Mac平台有其标准；和其它系统对接，也必须按照事先约定或者规定的标准来执行。即使是自己编写的程序，清晰简洁的接口也有助于程序员清晰地思路、快捷的执行效率。
标准化
最小化
精确化
用枚举代替const常量。  多个相关的常量用enum较好！！！！ 如Date类中的Month,Feburuy,,,

明白化
即好的接口设计应该简单易懂。



　　
6.2 函数模块化的优缺点
6.2.1 函数模块化的优点
　　很显然，运用模块化的函数具有很多的优点：   
1. 更加清晰简洁的代码。实现计算逻辑的分离 main函数一目了然，使代码更清晰（通过使用函数名）声明函数好比为箱子贴上标签。（不够贴切？）
2. 利于代码重用。更加使同样的代码在程序中多次使用，函数的使用可以避免变量和代码的重复； 代码更容易读懂。实际上，我们调用操作系统的API函数，也是这种方式，重用系统编写好的功能，重用的函数代码，可以是调用现有函数库中的函数，（编译器提供的库函数，Windows API (Mac  API), 或第三方提供的函数库），也可以是自己编写的函数。
3. 便于调试修改。减少程序调试的工作量，便于修改，减少耦合，修改其中一个不影响其它函数功能 （举例）。黑盒子 （避免外界修改）。
4. 便于分工协作。便于将工作分配给开发团队中的不同人员

6.2.2 模块的缺点
模块化的缺点往往容易被忽略，但我们也需要考虑到，来进行设计权衡。
1. 效率有所降低
模块化主要强调的是可分离可组合的灵活性，效率则不如一体化的。
如手机中的可换电池与不可换电池的设计，iMac的一体化。
2. 需要更多的存储空间
需要更多的变量保存中间计算结果。
3. 影响整体性
尤其在模块划分过细的时候，这个问题比较突出。


6.3 函数的声明和定义
6.3.1 可前置的函数声明

　　举例   max 函数


6.3.2 可外置的函数声明和定义
当需要将主函数划分为几个子函数时，应该都是代码比较复杂了，如果只是仅仅把函数声明前置，而把函数的定义代码保留在主文件的话，既暴露了实现的细节，又不利于工作分工，同时阅读起来，也会有喧宾夺主的感觉。这时，我们采用多文件结构的方式来组织代码，将函数的声明和定义分别外置。
　　通常的做法是：
　　将函数声明放到一个.h文件中，将函数的定义放到另外一个.cpp文件中，（虽然不要求同名，但是同名可以让代码更容易关联起来更易阅读），然后在需要调用这个函数的地方用#include语句加载头文件。
　　
  同样根据前面的max函数来举例


6.4 函数的调用
6.4.1 参数传递的几种形式
1. 传值
2. 传引用
3. 传指针
6.4.2 函数调用的修饰符
fastcall _stdcall
6.4.3 回调函数的调用规范
　　在注册1个回调函数时，我们常常使用函数指针。到目前为止，我们只讨论了函数指针及回调而没有去注意ANSI C/C++的编译器规范。许多编译器有几种调用规范。如在Visual C++中，可以在函数类型前加_cdecl，_stdcall或者_pascal来表示其调用规范（默认为_cdecl）。C++ Builder也支持_fastcall调用规范。调用规范影响编译器产生的给定函数名，参数传递的顺序（从右到左或从左到右），堆栈清理责任（调用者或者被调用者）以及参数传递机制（堆栈，CPU寄存器等）。 

6.5 几种特殊的C++函数类型 
6.5.1 内联函数（自备）
十五、Ｃ++的特性
Ｃ++新增加有重载(overload)，内联（inline），Const，Virtual四种机制
重载和内联：即可用于全局函数，也可用于类的成员函数；
Const和Virtual：只可用于类的成员函数；
重载：在同一类中，函数名相同的函数。由不同的参数决定调用那个函数。函数可要不可要Virtual关键字。和全局函数同名的函数不叫重载。如果在类中调用同名的全局函数，必须用全局引用符号::引用。
覆盖是指派生类函数覆盖基类函数：函数名相同；参数相同；基类函数必须有Virtual关键字；不同的范围(派生类和基类)。
隐藏是指派生类屏蔽了基类的同名函数相同
1、 函数名相同，但参数不同，此时不论基类有无Virtual关键字，基类函数将被隐藏。
2、 函数名相同，参数也相同，但基类无Virtual关键字(有就是覆盖)，基类函数将被隐藏。
内联：inline关键字必须与定义体放在一起，而不是单单放在声明中。
Const：const是constant的缩写，“恒定不变”的意思。被const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。
1、 参数做输入用的指针型参数，加上const可防止被意外改动。
2、 按值引用的用户类型做输入参数时，最好将按值传递的改为引用传递，并加上const关键字，目的是为了提高效率。数据类型为内部类型的就没必要做这件事情；如：
将void Func(A a) 改为void Func(const A &a)。
而void func(int a)就没必要改成void func(const int &a);
3、 给返回值为指针类型的函数加上const，会使函数返回值不能被修改，赋给的变量也只能是const型变量。如：函数const char*GetString(void); char *str=GetString()将会出错。而const char *str=GetString()将是正确的。
4、 Const成员函数是指此函数体内只能调用Const成员变量，提高程序的键壮性。如声明函数 int GetCount(void) const;此函数体内就只能调用Const成员变量。
Virtual：虚函数：派生类可以覆盖掉的函数，纯虚函数：只是个空函数，没有函数实现体；






（1） 内联函数与宏定义的区别，它们各有什么优点
　　内联函数与宏定义的区别(转载)2010-01-05 8:59认识内联函数和宏定义，需要注意以下几点： 
　　1.内联函数在运行时可调试，而宏定义不可以;
　　
　　2.编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
　　3.内联函数可以访问类的成员变量，宏定义则不能； 
　　4.在类中声明同时定义的成员函数，自动转化为内联函数。
　　
　　内联函数与宏定义
　　
　　（1）在C中，常用预处理语句#define来代替一个函数定义。例如： 
　　　　　　#define MAX(a，b) ((a)>(b)?(a):(b)) 
　　　　该语句使得程序中每个出现MAX(a,b)函数调用的地方都被宏定义中后面的表达式((a)>(b)?(a):(b))所替换。
　　（2）宏定义语句的书写格式有过分的讲究， MAX与括号之间不能有空格，所有的参数都要放在括号里。尽管如此，它还是有麻烦： 
　　　　　　int a=1，b=0；
　　　　　　MAX(a++,b)； //a被增值2次 
　　　　　　MAX(a++,b+10)； //a被增值1次 ;
　　　　　　MAX(a,"Hello")； //错误地比较int和字符串，没有参数类型检查 
　　　　　　MAX( )函数的求值会由于两个参数值的大小不同而产生不同的副作用。 
　　　　　　MAX(a++,b)的值为2，同时a的值为3； 
　　　　　　MAX(a++,b+10)的值为10，同时a的值为2。  
　　
　　（3）如果是普通函数，则MAX(a,"HellO")会受到函数调用的检查，但此处（宏定义）不会因为两个参数类型不同而被编译拒之门外。幸运的是，内联函数可以得到所有宏的替换效能和所有可预见的状态，以及常规函数的参数类型检查： 
　　　　　　inline int MAX(int a，int b)
　　　　　　{ 
　　　　　　　return a>b?a:b； 
　　
　　 
　　
　　
　　
　　
　　
内联函数  （去图书馆借书与自己买书的例子  内存（资源 ）吃紧与没钱）Inline  系统默认对栈和堆内存的处理方式及原因    以及函数的存储位置
用体积换速度
保存现场   恢复现场
仅在对性能要求很高时才使用内联函数
如果重新改写内联函数，会强迫开发人员重新编译整段代码，而对于非内联函数，则只需要重新链接即可。

内联函数语法简单，只要在声明的时候加上Inline关键字，调用与普通函数无异。
但是要理解其语义：
内联函数的使用规则：
有利有弊，需要扬长避短，权衡利弊。
1． 内联函数要代码简短
  会增加程序代码的体积，一般不要超过5行。尤其是该函数被多次调用的时候，程序的体积迅速膨胀，虽然从代码层没有过多重复的代码，但是在底层有很多相同的函数代码。

2.内联函数执行时间要短
  不仅要简短，而且执行时间也要短。如果执行时间远大于函数调用时间，通过内联函数省下的函数调用时间也就无关轻重了。

2． Inline关键字只是对编译器的一种建议
在某些情况下，比如说栈内存吃紧的时候，（待确定！！） 编译器将不理会Inline关键字，强制让函数成为普通函数。 但是编译器觉得两者方式都可以，无法准确估计代码效率的时候，会按照程序员的意图来执行。
可以理解：代码是程序员和编译器共同来编写的，必须了解清楚，合作好


因此，内联只能在一定情况下，可以提高程序的性能。

80%的时间是花在20%的代码上面。

6.5.2 函数重载（同样的名称，在不同上下文，不同的含义）


函数就是一段能够被引用的代码，例如使用函数指针。一般的，方法名会作为引用方法的唯一 id，但是，这就需要小心有重载的情况。C++ 和 Objective-C 使用截然不同的两种方式去区分：前者使用参数类型，后者使用参数标签。
在 C++ 中，只要函数具有不同的参数类型，它们就可以具有相同的名字。const 也可以作为一种重载依据。

无处不在的类型！ 静态的注重类型！


以前的做法：eatMeat()
eatFish()
…

缺点：

前面接触过，数组相当于变量名的重载

常见错误：
在函数重载和参数默认之间，谨慎选择



函数重(chong)载（function reload）   函数名的重用  语义上也更加自然 比如说吃 东西  吃鱼 吃饭  

根据输入参数的个数以及类型来区分，不包含返回值的原因是 返回值类型的隐含转换，并且函数在调用时，返回值不是必须的，这样程序就无法区分了
 
编译器无法根据函数的返回值类型来区分两个具有相同名称的函数
Int display(char ch); 
Bool   display(char ch);

编译错误在于：参数表（而非返回值类型）必须不同

为什么返回值类型的不同步足以将函数重载呢？因为返回值类型无法保证提供我们一个足以区分不同重载函数的情境。例如，编译器无法判断下面的函数调用操作究竟是想调用哪个函数。

Display(‘a)；


如果没有重载机制，我们就得为每个函数提供不同的名称。既繁琐又不简洁。让计算机正确理解程序员的意图。


以 max()函数来举例
重载函数的匹配原则：
1． 先找个数和类型都符合的 （函数的形式参数不同不影响）
2． 
3．避免使用默认参数

函数重载 根据参数 ， 因为返回值的隐含转换，比如 int 到double。查找对应的重载函数

转换后类似 max_int_int   max_int_double  之类的名称

      2.重载 
     重载让语言变的简洁。一是使一些有相同含义的函数可以以相同的名字出现，区别就在于参数和返回类型；二是使用户自定义类型可以模拟内建类型的操作方式。在效率上，似乎对我们来说没什么影响:)


6.5.3 递归函数
　　如果递归函数内需要保存过多的信息，则可能会导致栈溢出，这样，在调试运行的时候会出错，调试信息栏会显示信息：First-chance exception in XXX.exe: 0xC00000FD: Stack Overflow.

比如求阶乘的递归函数：
　　int fact(int n)
　　{
　　	int data[1000000];
　　	int temp;
　　	if (n!=1)
　　		temp=n*fact(n-1);
　　	else
　　		temp=1;
　　	return temp;
　　}
　　
　　void main()
　　{
　　   int a=chain(10);
　　   cout<<a<<endl;
　　   return ;		
　　}
　　
　　运行上面的程序，在vc6下栈溢出，如果将data数组调小，则不会出错！
　　
用F11单步调试这个含递归函数的程序，了解程序执行的流程，观察变量值的变化。
　　
递归函数的调试方法举例  （堆、栈的保存）
　　
　　递归调用只是函数嵌套调用的一种特殊形式，子所以能够自己调用自己，是因为函数调用的时候实际上是根据函数名中保存的地址，保存当前的数据，然后跳转到目标地址，继续执行。因为现在的计算机本质上市串行处理的。某些编译器会在根据函数名识别出递归模式后，进行一定的优化，来提高时间效率和空间效率。
　　
递归函数：
　　递归函数（实质上是一种声明式编程方式  也就是说对于推理逻辑比较固定的， 只需要下达任务，让编译器自动产生最后执行的代码，优点是代码简短，符合人的思维方式，缺点是由于是固定通用的，可能对每个问题效率不一定是最好的， ） 编译器会自动优化，不一定比定制的差    快速开发原型，再替换成对应的过程式代码，
　　C++ 新标准中引入了并行处理，适用于多核CPU，则可以将任务分解组合，就是另外的设计思路了。思考下：如何有效分解？比如说二分法，两个核分别计算一半在相乘组合？
　　
　　
　　效率低的根源在于保存了过多的中间数据，进行了过多的跳转。在并行处理的时代，弱点已经不那么明显了。可见，技术的发展有时候是会重新捡起以前的技术，新瓶装旧酒。
　　
　　
　　在使用递归函数时，最重要的是先学会递归这种思维方式，找出其中递归的规律。和我们在使用循环语句时也需要查找规律一样。
　　
　　下面的例子是 将一个正整数颠倒输出的递归实现方式。
　　#include <iostream>
　　using namespace std;
　　
　　int divR(int num)  //·µ»ØÖµÎªµßµ¹ÅÅÐòºóµÄÊý
　　{	
　　	if (num/10==0)
　　		return num;
　　	
　　	int t=divR(num/10);
　　
　　	int temp=num%10;  
　　	int m=num/10;  
　　
　　	while(	m!=0)
　　	{		
　　		temp=temp*10;
　　		m/=10;
　　	}
　　
　　	t+=temp;
　　	return t;
　　}
　　
　　
　　main()
　　{
　　	int out=divR(7896);
　　
　　	cout<<out<<endl;
　　	return;
　　
　　}
　　
　　

6.5.4 函数指针 
6.5.4.1 指针也可以指向函数代码段
对于编译器来说，它是不区分数据代码和操作代码的，它只知道代码的执行和跳转，所有的代码都会还原到汇编语言的jump move等几个最基本的指令。函数我们也可以看做一段代码，因此，就容易理解函数指针的概念。因此，不管是数据还是算法，都可以看做一段代码。因此，就容易理解以函数作为参数等看似一系列高级做法。




　　函数指针很容易理解,顾名思义，指向某个函数的指针。函数名其实也相当于一种数据类型，指向一段代码    函数和其它数据代码在底层并没有本质性的区别。实质上, 函数名与数组名是基本类似的,不过用途不一样。

在数学中，函数的参数可以使另外一个函数，同样，编程中的函数也可以是另外一段代码。 函数中的函数。

在面向对象的设计中，函数指针占据非常重要的位置，有ANSI C我们可知函数名实际
上也是一种指针，指向函数的入口地址，但它又不同于普通的如int*、double*指针，看下
面的例子来理解函数指针的概念：
int funtion( int x, int y );
void main ( void ) 
{
       int (*fun) ( int x, int y );
 　　　int a = 10, b = 20;
 　　　function( a, b );
 　　　fun = function;
 　　　（*fun）( a, b );
 　　　　……
}
　　语句1定义了一个函数function，其输入为两个整型数，返回也为一个整型数（输入参
数和返回值可为其它任何数据类型）；语句3定义了一个函数指针，与int*或double*定义
指针不同的是，函数指针的定义必须同时指出输入参数，表明这是一个函数指针，并且*f
un也必须用一对括号括起来；语句6将函数指针赋值为funtion，前提条件是*fun和functi
on的输入参数和返回值必须保持一致。语句5直接调用函数function（），语句7是调用函
数指针，二者等效。
  
int (*fp)(int a);//声明了一个函数指针,fp是一个指向函数的指针

int fun1(int a)
{
  ....
} //定义了一个函数

void main()
{
  int a=0,res;
  res=fun1(a); //正常调用函数
  fp=&fun1; //让指针fp指向fun1;
  res=(*fp)(a); //通过指针调用函数fun1()
  fp=fun1; //这还是fun1的指针,为何?





函数存放在内存的代码区域内，它们同样有地址，我们如何能获得函数的地址呢？ 
　　如果我们有一个int test(int a)的函数，那么，它的地址就是函数的名字，这一点如同数组一样，数组的名字就是数组的起始地址。 
　　定义一个指向函数的指针用如下的形式，以上面的test()为例： 
int (*fp)(int a);//这里就定义了一个指向函数的指针 
　　函数指针不能绝对不能指向不同类型，或者是带不同形参的函数，在定义函数指针的时候我们很容易犯如下的错误。
int *fp(int a);//这里是错误的，因为按照结合性和优先级来看就是先和()结合，然后变成了一个返回整形指针的函数了，而不是函数指针，这一点尤其需要注意！ 
　　下面我们来看一个具体的例子：

#include <iostream>  
#include <string>  
using namespace std;  
  
int test(int a);  
  
void main(int argc,char* argv[])    
{  
    cout<<test<<endl;//显示函数地址  
    int (*fp)(int a);  
    fp=test;//将函数test的地址赋给函数学指针fp  
    cout<<fp(5)<<"|"<<(*fp)(10)<<endl;  
//上面的输出fp(5),这是标准c++的写法,(*fp)(10)这是兼容c语言的标准写法,两种同意,但注意区分,避免写的程序产生移植性问题!  
    cin.get();  
}  
  
int test(int a)  
{  
    return a;  
}

typedef定义可以简化函数指针的定义，在定义一个的时候感觉不出来，但定义多了就知道方便了，上面的代码改写成如下的形式：
#include <iostream>  
#include <string>  
using namespace std;  
  
int test(int a);  
  
void main(int argc,char* argv[])    
{  
    cout<<test<<endl;  
    typedef int (*fp)(int a);//注意,这里不是生命函数指针,而是定义一个函数指针的类型,这个类型是自己定义的,类型名为fp  
    fp fpi;//这里利用自己定义的类型名fp定义了一个fpi的函数指针!  
    fpi=test;  
    cout<<fpi(5)<<"|"<<(*fpi)(10)<<endl;  
    cin.get();  
}  
  
int test(int a)  
{  
    return a;  
} 





6.5.4.2 函数指针的数组
  当然从上述例子看不出函数指针的优点，但当引入函数指针数组的概念后，情况发生
巨大的变化，我们从上面例子可以得知，既然函数名可以通过函数指针加以保存，那们也
一定能定义一个数组保存若干个函数名，这就是函数指针数组。正确使用函数指针数组的
前提条件是，这若干个需要通过函数指针数组保存的函数必须有相同的输入、输出值。
     函数指针的普遍一个用途是:通过调用一个函数指针,根据实际情况来调用不同的函数实现。在实际编程中,函数指针的功能不是只用来简单的调用函数。它可以用来简化代码，通过 数组的结合，采用循环的方式，遍历数组，对同样的参数使用不同的函数进行不同的操作。
　　	double (*pF[5])(double)={sin,sqrt,cos};
　　
　　	for (int i=0;i<3;i++)
　　	{
　　		cout<<"结果是"<<pF[k](10.25)<<endl;
	}

也许大家说，这种方式虽然妙，但是传统的代码也蛮容易的，可以如下实现，似乎还更简单：
		cout<<"结果是"<<sin(10.25)<<endl;
		cout<<"结果是"<<sqrt(10.25)<<endl;
		cout<<"结果是"<<cos(10.25)<<endl;

     嗯，的确如此，但是随着函数规模的扩大，采用函数指针的代码比采用硬编码形式更具有灵活性。
下面再举一个实际系统的例子：
     在引入函数指针之前，根据调度函数抛出的消息，我们要进行函数调度，假设最多的任务为255，通常我们设计如下的函数；
Void Msg_Deal(Byte *Msg)
{
	Switch(*Msg)
    {
             case 0:
　　　　　　　　　　　function1();
　　　　　　　　　　　break;
　　　　　　　case 1:
　　　　　　　......
　　　　　　　case 255:
　　　　　　　　　　　function255();
　　　　　　　　      break;
}
}
   通过上面的例子可以看出，进行任务调度的函数非常长，假设任务长度不止255个，情况还会更加糟糕，因此我们必须设计更好的数据结构完成此项工作。
    在采用了前面提到的函数指针的数组技术后，开始的例子所面临的问题可以解决如下：首先定义256个处理函数(及其实现),
void funtion0( void );
……..
void funtion255(void );
其次定义函数指针数组，并给数组赋值；
void (*fun[256])(void);
fun[0] = function0;
…….
fun[255] = function();
最后，Msg_Deal ()函数可以修改如下：
Void Msg_Deal(Byte *Msg)
{
　　　　（*fun[*Msg）();
}
    只要1行代码，就完成了256条case语句要做的事，减少了编写代码时工作量，将*Msg
作为数组下标，直接调用函数指针，从代码执行效率上来说，也比case语句高。假如多个
函数中均要作如此处理，任务要进行增减，或者任务调度的顺序要改变，只需一两条语句
就能完成，函数指针数组更能体现出它的优势。

6.5.4.3 函数指针的缺点
前面谈了函数指针这么多的好处，下面也来谈谈其缺点：




6.5.4.4 复杂形式的函数指针的处理
　　还有很复杂的声明可能也是一种挑战 比如<<Think in c++>>里的 
int (*(*f4())[10]();的声明,f4是一个返回指针的函数，该指针指向了含有10个函数指针的数组，这些函数返回整形值；不是这个函数有特别之处，而是Bruce Eckel 说的“从右到左的辨认规则”是一种很好的方法，值得我们去学习，感谢他：) 




6.5.5 常见的系统函数

6.5.6 主函数的奥秘
主函数  系统调用 表示程序开始， return 0 表示正常结束，return  -1 或者其它代表异常终止情况

参数的意思 ，
如果需要在程序执行时接受命令行参数，则main()函数的格式如下。
voidmain(intargc,char * argv[] )
{
    …
}


数组作为函数参数 ，传递的只是数组的首地址(),必须加上另外一个参数  （举例，max(int a[])）与传值对应

返回值


winmain  main 函数  




6.5.7 字符串函数
字符串函数典型错误！

#include <iostream>
#include <cstring>
using namespace std;

void main()
{
      char * str1 = "You ";
      cout << "str1(before) = " << str1;
      char * str2 = "are good";
      strcat(str1, str2);
      cout << "str1(after) = " << str2;
}
这段程序编译连接可以通过.

执行strcat(st1, str2)句时会报错:" staticunion.exe 遇到问题需要关闭。我们对此引起的不便表示抱歉。"

后面的cout语句没有输出
谁能告诉我这是为什么

（1） strcat是不检查第一个串的大小的，如果发生错误，自己是不报错的，所以会由系统来做这个工作。
另外，你定义第一个串时用的是这样的形式char * str1 = "You ";，这个是一个常量，是不能改变的，一旦改变就会报错，而strcat正好要写第一个串，改变了那个内容，这个应该就是错误的所在，你可以将第一个串的声明形式写为char str1[100] = "you";  同时还要自己保证你的这个串能够存放下，连接进来的串的内容，否则就会越界，strcat不会检测这个，如果你不写控制处理，就会由系统来报此错误，就会出现程序运行不稳定的情况。
请楼主再想一下，需要怎么去判断下，那个越界的问题，其实很简单的。







6.6 函数模块的内部隐含工作机制
6.6.1 函数调用  代码跳转

6.6.2 参数传递传递 堆栈
　　

一 C++程序内存分配
1) 在栈上创建。在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，一般使用寄存器来存取，效率很高，但是分配的内存容量有限。 
2) 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete来释放内存。动态内存的生存期由程序员自己决定，使用非常灵活。 
3) 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。 
4) 文字常量分配在文字常量区，程序结束后由系统释放。 
5）程序代码区。 
经典实例：（代码来自网络高手，没有找到原作者）
Code 
#include <string> 

int a=0;    //全局初始化区 
char *p1;   //全局未初始化区 
 void main() 
{ 
    int b;//栈 
    char s[]="abc";   //栈 
    char *p2;         //栈 
    char *p3="123456";   //123456\0在常量区，p3在栈上。 
    static int c=0;   //全局（静态）初始化区 
    p1 = (char*)malloc(10); 
    p2 = (char*)malloc(20);   //分配得来得10和20字节的区域就在堆区。 
    strcpy(p1,"123456");   //123456\0放在常量区，编译器可能会将它与p3所向"123456\0"优化成一个地方。 
} 
复制代码
 
二 三种内存对象的比较 
　　栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要程序员操心；而且栈对象的创建速度一般较堆对象快，因为分配堆对象时，会调用operator new操作，operator new会采用某种内存空间搜索算法，而该搜索过程可能是很费时间的，产生栈对象则没有这么麻烦，它仅仅需要移动栈顶指针就可以了。但是要注意的是，通常栈空间容量比较小，一般是1MB～2MB，所以体积比较大的对象不适合在栈中分配。特别要注意递归函数中最好不要使用栈对象，因为随着递归调用深度的增加，所需的栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，这样就会产生运行时错误。 
　　堆对象创建和销毁都要由程序员负责，所以，如果处理不好，就会发生内存问题。如果分配了堆对象，却忘记了释放，就会产生内存泄漏；而如 果已释放了对象，却没有将相应的指针置为NULL，该指针就是所谓的“悬挂指针”，再度使用此指针时，就会出现非法访问，严重时就导致程序崩溃。但是高效的使用堆对象也可以大大的提高代码质量。比如，我们需要创建一个大对象，且需要被多个函数所访问，那么这个时候创建一个堆对象无疑是良好的选择，因为我们通过在各个函数之间传递这个堆对象的指针，便可以实现对该对象的共享，相比整个对象的传递，大大的降低了对象的拷贝时间。另外，相比于栈空间，堆的容量要大得多。实际上，当物理内存不够时，如果这时还需要生成新的堆对象，通常不会产生运行时错误，而是系统会使用虚拟内存来扩展实际的物理内存。
　　静态存储区。所有的静态对象、全局对象都于静态存储区分配。关于全局对象，是在main()函数执行前就分配好了的。其实，在main()函数中的显示代 码执行之前，会调用一个由编译器生成的_main()函数，而_main()函数会进行所有全局对象的的构造及初始化工作。而在main()函数结束之 前，会调用由编译器生成的exit函数，来释放所有的全局对象。比如下面的代码： 
void main（void） 
{ 
… …// 显式代码 
}实际上，被转化成这样： 
void main（void） 
{ 
_main（）; //隐式代码，由编译器产生，用以构造所有全局对象 
… … // 显式代码 
… … 
exit（） ; // 隐式代码，由编译器产生，用以释放所有全局对象 
}　　除了全局静态对象，还有局部静态对象通和class的静态成员，局部静态对象是在函数中定义的，就像栈对象一样，只不过，其前面多了个static关键字。局部静态对象的生命期是从其所在函数第一次被调用，更确切地说，是当第一次执行到该静态对象的声明代码时，产生该静态局部对象，直到整个程序结束时，才销毁该对象。class的静态成员的生命周期是该class的第一次调用到程序的结束。
三 函数调用与堆栈
1)编译器一般使用栈来存放函数的参数，局部变量等来实现函数调用。有时候函数有嵌套调用，这个时候栈中会有多个函数的信息，每个函数占用一个连续的区域。一个函数占用的区域被称作帧（frame）。同时栈是线程独立的，每个线程都有自己的栈。例如下面简单的函数调用：

另外函数堆栈的清理方式决定了当函数调用结束时由调用函数或被调用函数来清理函数帧，在VC中对函数栈的清理方式由两种：
参数传递顺序谁负责清理参数占用的堆栈__stdcall从右到左被调函数__cdecl 从右到左调用者2) 有了上面的知识为铺垫，我们下面细看一个函数的调用时堆栈的变化：
代码如下：



 
Code
int Add(int x, int y)
{
    return x + y;
}

void main()
{
    int *pi = new int(10);
    int *pj = new int(20);
    int result = 0;
    result = Add(*pi,*pj);
    delete pi;
    delete pj;
} 
复制代码
 
对上面的代码，我们分为四步，当然我们只画出了我们的代码对堆栈的影响，其他的我们假设它们不存在，哈哈!
第一，int *pi = new int(10);   int *pj = new int(20);   int result = 0; 堆栈变化如下：

第二，Add(*pi,*pj);堆栈如下：

第三，将Add的结果给result，堆栈如下：

第四，delete pi;    delete pj; 堆栈如下：

第五，当main()退出后，堆栈如下，等同于main执行前，哈哈！
　　
　　








第七章  结构体的凝聚力
   ——物以类聚

　　首先考虑下面的应用场合（分别截图！）：
　　在图形处理软件中，我们绘图时对象是线段、曲线、圆等，用这些基本的形状组合成更复杂的形状。
　　在图形游戏中，如“俄罗斯方块”，对象就是由小正方形构成的各种不同平面形状，根据集合形状的外观特点，通过旋转、平移等方式进行拼接相消（截图？）
　　在文字处理类软件如word中，我们处理的基本对象是  字符串（句子）  图  如果挨个字符char处理，通过合理地组合，形成一篇美观的文档。
　　
　　如果我们要编写这类程序，为了合理描述这些基本的对象，使问题思考更方便，可以使用在前面我们已经学习过struct 类型（结构体），也明白了通过定义结构体的这种方式引入新的数据类型， 而不是停留在int  float char  这些C++语言内置的数据类型上。
　　自定义的数据类型。
7.1 兼收并蓄的包容
7.1.1 汇聚多种简单类型
　　相区别于前面已经学过的简单数据类型，结构体这种复合的数据类型，是用来描述复杂的事物的，如描述一个圆需要圆心和圆的半径。
　　因此，组合到结构体内的是多个数据类型，可以相同，也可以不同。语法结构如下
　　Struct 结构体名
　　{
　　	数据类型1   成员名1；
　　    数据类型2   成员名1；
　　    
　　    数据类型n   成员名n；
　　}
　　
　　Windows开发中，定义了一些常见的基本元素，如图形开发中，
　　Point
　　{
　　    Double x;
　　	Double y;
　　}
　　用来描述一个二维点，
　　Point
　　{
　　    Double x;
　　	Double y;
　　Double z；
　　}
　　描述一个三维点。
　　
　　
　　

　　在老的标准中，struct这种类型中只含有数据，这些类型并不抽象，它们像“int”和”float”一样实际。 后来，在结构体中引入了函数。是数据和函数有了一定的关联。
　　但是，引入函数，和类有某些相同点，基于对象，但是仅仅是为了保持兼容性。因此，我们在实际应用时，对于单纯的表示数据的聚合，用结构体Struct，而对于包含成员函数的，
　　直接用类 Class 。
　　
　　结构体这种用户自定义的数据结构，和系统定义好的基本数据类型具有同样的地位和作用。
　　
　　多一份就多，少一份就少
7.1.2 一层层的嵌套
结构体内不仅仅可以包含简单的数据类型，也可以包含结构体，如：


嵌套使用为更复杂的数据类型。达到“山外青山楼外楼”的效果。


甚至可以包含自己本身，注意，要以指针的方式，（和非指针的方式情况对比），因为要在
分配内容，指针的大小是固定的4个字节。


通过这种嵌套使用的方式，可以形成相当复杂的数据结构。

在使用的时候，也是采用加点的语法形式，不过，太复杂的结构体肯定是不可取的。


7.1.3 甚至包含函数
通常我们将结构体用作数据结构，但是实际上，为了保持和class类的兼容性，结构体中也能包含成员函数。但这种做法不提倡，仅在需要考虑兼容性的时候使用。


7.2 结构体数据的访问
7.2.1 先声明后使用
两种方式，类似于函数


7.2.2 访问方式


最常见的是.  点运算符


成员选择运算符->   ，它使用指针访问结构的成员，在键盘输入一个减号和一个大于号，就得到了成员选择运算符。在指针指向结构体后（将结构体地址赋值给指针变量），可以使用如下形式访问结构体成员：
   结构体指针->成员名；
 举例：


用指针访问结构成员的另外一种等价表现形式是：
（*结构指针）.成员名
但是这种显然比较繁琐，使用较少。





7.3 结构体内数据的位置
7.3.1 有序的存储
结构体在存储的时候，是采用类似数组的形式，分配一块连续的内容，（汇编来验证）
存储的顺序是按照声明的顺序。

赋值初始化时，
挨个成员赋值，不要用省略了成员变量的初始化列表


key hsarm1={"华山剑", 2};
Wea hsskill1={"华山刀法", 0, 5, 1, 5};
结构体初始化后不能再用列表{}赋值，只能一个一个成员赋值，或者你写个构造函数赋值

struct student 里面有个 string name  就不能直接用初始化列表进行赋值！
可进行串行初始化的数据结构中是不能够有construct、private、protected等且没有基类的联合体、结构体、类。其成员也必须符合这样的条件。

由于在C++中class和struct类型的兼容性，因此，如果将前面的class 关键字换成struct，结果是一样的，大家可以自行测试下。

7.3.2 奇怪的结构体大小
结构体经常作为参数传递给函数，有时候会有个很奇怪的问题。在很多时候读写的时候是按照字节来操作的，因此需要准确算出结构体的字节数。
既然前面已经提到结构体是按照数组来存储的，那么计算其大小好像很简单，像数组一样，size*number;但实际上真的是这样吗？
   我们测试下：



#include<iostream>
using namespace std;

class  Test
{
   int a;
   char b;
};

void main()
{

 Test test;
 cout<<sizeof(int)<<endl;
 cout<<sizeof(char)<<endl;
 cout<<sizeof(test)<<endl;
		
}

首先实测出在本机运行环境下，sizeof（int）为4个字节，sizeof(char)为1个字节。
然后，我们进行下面三类测试：
类 Test为空， sizeof结果为1
类Test中添加1个int类型变量，sizeof结果为4
类Test中添加1个char类型变量，sizeof结果为8



为什么会出现

内存对齐！	  特别是程序中涉及到数据的传送的时候，必然读写文件指定数组大小，C/S架构程序端口传输数据时，如果不知道这点，就会对神奇的错误结果百思不得其解。


一个故事：在网络传输的时候，发觉收到的内容不对，调试发现发送和接收到的不一样，初始还以为传输的问题，后来才明白是字节对齐问题引起的socket函数问题。
   字节对齐的表现形式是 结构体的大小并不是其成员变量的大小总和！！
   
   作出这样的设计是因为内存在逻辑的分页机制，为了避免换页的低效，而c++语言与C语言一样，特别注重效率，因此，不惜牺牲直观性而设计了字节对齐的规则。
　　
  首先，至少有一点可以肯定，那就是ANSI C保证结构体中各字段在内存中出现的位置是随它们的声明顺序依次递增的，并且第一个字段的首地址等于整个结构体实例的首地址。

  这时，有朋友可能会问:"标准是否规定相邻字段在内存中也相邻?"。 唔，对不起，ANSI C没有做出保证，你的程序在任何时候都不应该依赖这个假设。那这是否意味着我们永远无法勾勒出一幅更清晰更精确的结构体内存布局图？

　　
关于字节对齐


10.计算结构变量的大小就必须讨论数据对齐问题。为了使CPU存取的速度最快（这同CPU取数操作有关，详细的介绍可以参考一些计算机原理方面的书），C＋＋在处理数据时经常
把结构变量中的成员的大小按照4或8的倍数计算，这就叫数据对齐。这样做可能会浪费一些内存，但在理论上CPU速度快了。当然这样的设置会在读写一些别的应用程序生成的数据文件或交换数据时带来不便。MS VC＋＋中的对齐设定，有时候sizeof得到的与实际不等。一般在VC++中加上pragma pack(n)的设定即可。或者如果要按字节存储，而不进行数据对齐，可以在Options对话框中修改Advanced Complier选项卡中的“Data Alignment”为按字节对齐。






.计算struct的size有两个原则：
（1）struct中各成员按照对齐原则：在为当前变量（设为a）分配内存时，要参考之前所有变量的偏移量之和（设为d），d必须是min(n,sizeof(a))的倍数，否则编译器会自动在最后补上缺少的字节数。（2）待所有变量都分配完毕之后，还要比较当前所占内存（设为c）与struct中长度最大的变量的长度（设为b），c必须是b的倍数，否则编译器也会在最后补上缺少的字节数。



1. 内存对齐:计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常它为4或8)的倍数k则被称为该数据类型的对齐模数(alignment modulus)
2.不同编译器默认的最大对齐字节数是不一样的,比如vc==8,gcc==4,可以通过#progma pack (n)来修改,分析程序的时候要注意编译器的区别
3.一个结构体里面,按照alignment modulus最大的数据成员来进行对齐,超过编译器规定最大的对齐字节个数,按编译器最大对齐字节个来
4.double类型在vc里面alignment modulus == 8,而在gcc里面由于默认最大对齐个数是4,不设置的话,alignment modulus == 4
5.因为数组各元素之间不能有空隙,所以{int a;char b;}  
这种情况,默认在VC里面也需要占8个字节.



  许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常它为4或8)的倍数，这就是所谓的内存对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。这种强制的要求一来简化了处理器与内存之间传输系统的设计，二来可以提升读取数据的速度。比如这么一种处理器，它每次读写内存的时候都从某个8倍数的地址开始，一次读出或写入8个字节的数据，假如软件能保证double类型的数据都从8倍数地址开始，那么读或写一个double类型数据就只需要一次内存操作。否则，我们就可能需要两次内存操作才能完成这个动作，因为数据或许恰好横跨在两个符合对齐要求的8字节内存块上。某些处理器在数据不满足对齐要求的情况下可能会出错，但是Intel的IA32架构的处理器则不管数据是否对齐都能正确工作。不过Intel奉劝大家，如果想提升性能，那么所有的程序数据都应该尽可能地对齐。Win32平台下的微软C编译器(cl.exe for 80x86)在默认情况下采用如下的对齐规则:
 
  现在回到我们关心的struct上来。ANSI C规定一种结构类型的大小是它所有字段的大小以及字段之间或字段尾部的填充区大小之和。嗯？填充区？对，这就是为了使结构体字段满足内存对齐要求而额外分配给结构体的空间。那么结构体本身有什么对齐要求吗？有的，ANSI C标准规定结构体类型的对齐要求不能比它所有字段中要求最严格的那个宽松，可以更严格(但此非强制要求，VC7.1就仅仅是让它们一样严格)。我们来看一个例子(以下所有试验的环境是Intel Celeron 2.4G + WIN2000 PRO + vc7.1，内存对齐编译选项是"默认"，即不指定/Zp与/pack选项):


7.4 灵活多样的搭配
　　结构体也是一种数据类型，因此它可以广泛使用，和前面已经学过的循环、数组、指针、函数搭配使用，几乎可以无缝连接。

7.4.1 结构体与数组

结构体也是一种数据结构，因此有结构体的数组，和结构体的指针

　学生成绩的例子。
　
　

7.4.2 结构体与函数
结构体的一个重要用途，是用来作为函数的参数。

例如，要画一条从点（x1,y1,z1）到点（x2,y2,z2）的线段，函数
drawLine(x1,y1,z1,x2,y2,z2……
仅仅是描述两个起点和终点就需要用6个参数来描述，如果再加上其它描述线型、颜色等属性的参数，不仅繁琐，而且容易出错。

如果改用结构体的话，将相关的概念聚合在一起。则先定义
Point_3D
{
	Double x;
　　Double y;
　　Double z;
}；

Point_3D  Point_From,Point_To;
drawLine(Point_From, Point_To…) ,就简洁易懂多了，对其余参数类似处理，就可以得到一个更简洁易懂的函数接口设计。
 
当然，由于结构体默认为传值，如果结构体比较大的话，可以采用引用或者指针作为参数的方式来优化函数调用的效率。





7.5 PLD   Plain Old Datastructure的优点

尽可能保持简单。




第八章  生命周期与作用域
                       ———穿梭于代码的时空
 在代码的空间中遨游，会在这个虚拟的空间中遇到各类代码，好比浩瀚的宇宙空间。
对于每个部件，可以从时空中来观察。即相当于代码中的生命周期和作用域。
    生命周期是指从诞生到消亡，作用域是指生效的范围。这些对于部件来说，是边界的约束，相对独立了各自的活动，将对别的代码的影响可控。想要潇洒穿梭于代码的时空，不要迷失自我，就好了解其规律。


8.1 生命周期

8.2 作用域

8.2.1 可靠的屏蔽门（大括号）
语句块作用域
函数  函数作用域  局部变量  临时变量  参数临时变量  函数返回值

8.2.2 物理隔离的组件（文件）
文件域的变量不可见？

大型程序中，接口与实现分离。头文件包含函数的声明
可以在一个头文件中声明多个头文件 （如库文件） 或者 实现与头文件都包含相关的声明和定义 （）

　　（文件 工程）


头文件的秘密
2 头文件的作用
这是由于历史原因造成的。
头文件主要用于存放接口声明，以便不同的c文件共享函数声明。
到了c++中，已经造成一种妨碍了。
十八、#IFNDEF/#DEFINE/#ENDIF有什么作用
仿止该头文件被重复引用
一、#include “filename.h”和#include <filename.h>的区别
#include “filename.h”是指编译器将从当前工作目录上开始查找此文件
#include <filename.h>是指编译器将从标准库目录中开始查找此文件

二、头文件的作用
加强安全检测
通过头文件可能方便地调用库功能，而不必关心其实现方式
这里对头文件
的作用略作解释：
（1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用
户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。
（2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这
一简单的规则能大大减轻程序员调试、改错的负担。
 
 
一般来说，头文件提供接口，源文件提供实现。但是有些实现比较简单的，也可以直接写在头文件里，这样头文件接口实现一起提供。

在编译时，源文件里的实现会被编译成临时文件，运行时刻程序找到头文件里的接口，根据接口找到这些临时文件，来调用它们这些实现。之所以在 C++ 中要使用头文件，最主要的原因是 C++ 的同一个项目可能有多个源代码文件，要命的是这些源代码是分别单独编译的。
也就是说，在编译其中一个文件时，编译器并不知道其它文件中定义的内容，如类、全局变量等。
这就要求我们必须在要使用某个类、函数或变量的每个文件中声明它，否则 C++ 是无法找到它的。
 
很多文件可能都需要使用加法。假设有一个文件 b.cpp 需要使用这个函数，那么，它必须先声明它，虽然不需要再重写。
 
如果有很多文件都要使用这个函数，那么这会变得麻烦，特别的，如果你写了一个类，那么你需要维护大量的声明（对于每一个 public 对象），并且如果你的类的定义发生了改变，你可能不得不改变无数个声明。
所以，C++ 语言提出了头文件的概念。你只需要在头文件中声明一次，在实现文件中定义一次，在所有需要用的文件中，就只需要引用这个头文件，相当于每个文件都包含了一个声明。
为了防止头文件的重复包含，通常应该使用预处理指令 #define （定义符号）、#ifndef（如果没有定义）、#endif（结束判断）来书写头文件的内容。
请理解如下的例子，它是对上个笔记中的 Xiao 类的改进。

.2 头文件的结构
头文件由三部分内容组成：
（1）头文件开头处的版权和版本声明（参见示例1-1）。
（2）预处理块。
（3）函数和类结构声明等。
假设头文件名称为 graphics.h，头文件的结构参见示例1-2。
【规则1-2-1】为了防止头文件被重复引用，应当用ifndef/define/endif结构产生预处理块。
【规则1-2-2】用 #include <filename.h> 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。
【规则1-2-3】用 #include “filename.h” 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。
【建议1-2-1】头文件中只存放“声明”而不存放“定义”
在C++ 语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。
【建议1-2-2】不提倡使用全局变量，尽量不要在头文件中出现象extern int value 这类声明。

// 版权和版本声明见示例1-1，此处省略。
#ifndef   GRAPHICS_H  // 防止graphics.h被重复引用
#define   GRAPHICS_H
#include <math.h>     // 引用标准库的头文件
…
#include “myheader.h”   // 引用非标准库的头文件
…
void Function1(…);   // 全局函数声明
…
class Box             // 类结构声明
  {
  …
  };
#endif
示例1-2 C++/C头文件的结构
1.3 定义文件的结构
定义文件有三部分内容：
（1）       定义文件开头处的版权和版本声明（参见示例1-1）。
（2）       对一些头文件的引用。
（3）       程序的实现体（包括数据和代码）。
假设定义文件的名称为 graphics.cpp，定义文件的结构参见示例1-3。

// 版权和版本声明见示例1-1，此处省略。
#include “graphics.h”     // 引用头文件
…
// 全局函数的实现体
void Function1(…)
  {
  …
  }
// 类成员函数的实现体
void Box::Draw(…)
  {
  …
  }
示例1-3 C++/C定义文件的结构

8.2.3 可控的许可授权（命名空间）
　　匿名命名空间的作用？ 
　　





命名空间（引入的历史和缘故，c语言中的替换做法）



8.3 代码空间的生命体
8.3.1 普通变量、临时变量与静态变量
变量的生命周期、静态变量的
全局变量  局部变量  静态变量    都是变量的作用域
（19）知道局部变量为什么比全局变量快么？


文件作用域    头文件（linux 等系统）  头文件重复包含  全局变量 静态变量 
（1）局部变量全局变量静态变量 const常量寄存器变量宏定义的常量 static变量 

注：包括它们的内存分配区域，作用域，初始化等等

表格展示：
define  字符简单替换，无数据类型，可能产生意想不到的错误  ，不能调试
const  常量数据类型，类型安全检查，集成化调试工具对常量进行调试

8.3.2 常量


8.3.3 常量表达式  constExpr







147


